[{"title":"MySQL重置密码","url":"/2018/05/30/mysql重置密码/","content":"## 重置密码 ##\n\n 1. 关闭MySQL服务                       \n    `/usr/local/mysql/support-files/mysql.server`\n 2. 切换目录\n    `cd /usr/local/mysql/bin`\n 3. 获取权限\n    `sudo su`\n 4. 重启服务\n    `./mysqld_safe --skip-grant-tables`\n 5. 重开终端\n    `alias mysql=/usr/local/mysql/bin/mysql`\n 6. 进入MySQL命令模式\n    `mysql`\n 7. 选择MySQL数据库\n    `use MySQL`\n 8. 刷新权限\n    `flush privileges`\n 9. 重置密码\n    `set password for ‘root’@’localhost’=password(‘新密码’)`\n\n\n\n \n## 常用操作 ##\n\n 1. 登录\n    `mysql -u root -p XXX`\n 2. 创建用户\n    `create user 'test'@'localhost' identified by '123456'`\n 3. 刷新授权\n    `\\flush privileges`\n\n ","categories":["反编译"]},{"url":"/2018/02/05/腾讯直播/","content":"最近公司弄了一个在线娃娃机项目，用到了腾讯直播，期间遇到了许多问题，再次记录一下。\n腾讯云的直播产品非常多，文档也比较全，但是最大的问题是相互依赖，你可能要解决一个问题，要从直播找起，然后点播，然后互动直播，有点乱，再次整理一下。\n##名词解释：\n###直播码：\n> md5(房间号_用户名_main)\n\n```\nBIZID=8888,用户名=14y2l2c，房间号=293710\n直播码 = md5(293710_14y2l2c_main)=81265058829fd2e50c8ec2ac78d55127\n播放地址=传输协议://BIZID.liveplay.myqcloud.com/live/直播码[.格式\n\n```\n```\n生成后的旁路直播地址\nrtmp:rtmp://8888.liveplay.myqcloud.com/live/8888_81265058829fd2e50c8ec2ac78d55127\nflv: http://8888.liveplay.myqcloud.com/live/8888_81265058829fd2e50c8ec2ac78d55127.flv\nhls:http://8888.liveplay.myqcloud.com/live/8888_81265058829fd2e50c8ec2ac78d55127.m3u8\n```\n\n###BIZID\n\n> 在直播——>接入管理——>直播码接入可以找到\n\n![BIZID地址](http://ww1.sinaimg.cn/large/d948997dgy1fo5faoupnyj21vy0bc0x1.jpg)\n\n\n\t\n##产品名：\n###点播\n####主要功能\n\n1. 音视频的存储管理，不管是点播还是互动直播的录制的视频，都把存在点播下面\n2. 音视频的转码\n3. 音视频的播放\n\n###直播\n####主要功能\n1. 推流\n2. 播放\n**与点播相比，主要可以区别在于可以推流**\n\n###互动直播\n####主要功能\n\n\n\n\n\n\n\n\n\n\n"},{"url":"/2017/10/12/android api/","content":"## Android 简介\n\nhttps://developer.android.google.cn/guide/index.html\n\n## 应用基础知识\n\nhttps://developer.android.google.cn/guide/components/fundamentals.html\n\n## 设备兼容性 Device Compatibility\n\nhttps://developer.android.google.cn/guide/practices/compatibility.html\n\n## 系统权限\n\nhttps://developer.android.google.cn/guide/topics/security/permissions.html\n\n## 平台架构\n\nhttps://developer.android.google.cn/guide/platform/index.html\n\n## 使用 Java 8 语言功能\n\nhttps://developer.android.google.cn/guide/platform/j8-jack.html\n\n## 在 Android Runtime (ART) 上验证应用行为\n\nhttps://developer.android.google.cn/guide/practices/verifying-apps-art.html\n\n## 应用组件\n\nhttps://developer.android.google.cn/guide/components/index.html\n\n## Intent 和 Intent 过滤器\n\nhttps://developer.android.google.cn/guide/components/intents-filters.html\n\n## 通用 Intent\n\nhttps://developer.android.google.cn/guide/components/intents-common.html\n\n## Activity\n\nhttps://developer.android.google.cn/guide/components/activities.html\n\n## 片段 fragment\n\nhttps://developer.android.google.cn/guide/components/fragments.html\n\n## 加载器\n\nhttps://developer.android.google.cn/guide/components/loaders.html\n\n## 任务和返回栈\n\nhttps://developer.android.google.cn/guide/components/tasks-and-back-stack.html\n\n## 概览屏幕\n\nhttps://developer.android.google.cn/guide/components/recents.html\n\n## 服务\n\nhttps://developer.android.google.cn/guide/components/services.html\n\n## 绑定服务\n\nhttps://developer.android.google.cn/guide/components/bound-services.html\n\n## Android 接口定义语言 (AIDL)\n\nhttps://developer.android.google.cn/guide/components/aidl.html\n\n## 内容提供程序\n\nhttps://developer.android.google.cn/guide/topics/providers/content-providers.html\n\n## 内容提供程序基础知识\n\nhttps://developer.android.google.cn/guide/topics/providers/content-provider-basics.html\n\n## 创建内容提供程序\n\nhttps://developer.android.google.cn/guide/topics/providers/content-provider-creating.html\n\n## 日历提供程序\n\nhttps://developer.android.google.cn/guide/topics/providers/calendar-provider.html\n\n## 联系人提供程序\n\nhttps://developer.android.google.cn/guide/topics/providers/contacts-provider.html\n\n## 存储访问框架\n\nhttps://developer.android.google.cn/guide/topics/providers/document-provider.html\n\n## 应用小部件 App Widgets\n\nhttps://developer.android.google.cn/guide/topics/appwidgets/index.html\n\n## 应用小部件主机 App Widget Host\n\nhttps://developer.android.google.cn/guide/topics/appwidgets/index.html\n\n## 进程和线程\n\nhttps://developer.android.google.cn/guide/components/processes-and-threads.html\n\n## 应用资源 App Resources\n\nhttps://developer.android.google.cn/guide/topics/resources/index.html\n\n## 资源概览\n\nhttps://developer.android.google.cn/guide/topics/resources/overview.html\n\n## 提供资源\n\nhttps://developer.android.google.cn/guide/topics/resources/providing-resources.html\n\n## 访问资源\n\nhttps://developer.android.google.cn/guide/topics/resources/accessing-resources.html\n\n## 处理运行时变更\n\nhttps://developer.android.google.cn/guide/topics/resources/runtime-changes.html\n\n## 本地化 Localizing with Resources\n\nhttps://developer.android.google.cn/guide/topics/resources/localization.html\n\n## ICU4J Android 框架 API\n\nhttps://developer.android.google.cn/guide/topics/resources/icu4j-framework.html\n\n## 语言和语言区域\n\nhttps://developer.android.google.cn/guide/topics/resources/multilingual-support.html\n\n## 资源类型 Resource Types\n\nhttps://developer.android.google.cn/guide/topics/resources/available-resources.html\n\n## 动画 Animation Resources\n\nhttps://developer.android.google.cn/guide/topics/resources/animation-resource.html\n\n## 颜色状态列表 Color State List Resource\n\nhttps://developer.android.google.cn/guide/topics/resources/color-list-resource.html\n\n## 可绘制对象\n\nhttps://developer.android.google.cn/guide/topics/resources/drawable-resource.html\n\n## 布局 Layout Resource\n\nhttps://developer.android.google.cn/guide/topics/resources/layout-resource.html\n\n## 菜单 Menu Resource\n\nhttps://developer.android.google.cn/guide/topics/resources/menu-resource.html\n\n## 字符串\n\nhttps://developer.android.google.cn/guide/topics/resources/string-resource.html\n\n## 样式 Style Resource\n\nhttps://developer.android.google.cn/guide/topics/resources/style-resource.html\n\n## 其他类型 More Resource Types\n\nhttps://developer.android.google.cn/guide/topics/resources/more-resources.html\n\n## 应用清单\n\nhttps://developer.android.google.cn/guide/topics/manifest/manifest-intro.html\n\n## 用户界面\n\nhttps://developer.android.google.cn/guide/topics/ui/index.html\n\n## UI 概览\n\nhttps://developer.android.google.cn/guide/topics/ui/overview.html\n\n## 布局\n\nhttps://developer.android.google.cn/guide/topics/ui/declaring-layout.html\n\n## 线性布局\n\nhttps://developer.android.google.cn/guide/topics/ui/layout/linear.html\n\n## 相对布局 Relative Layout\n\nhttps://developer.android.google.cn/guide/topics/ui/layout/relative.html\n\n## 列表视图\n\nhttps://developer.android.google.cn/guide/topics/ui/layout/listview.html\n\n## 网格视图 Grid View\n\nhttps://developer.android.google.cn/guide/topics/ui/layout/gridview.html\n\n## 输入控件\n\nhttps://developer.android.google.cn/guide/topics/ui/controls.html\n\n## 按钮 Buttons\n\nhttps://developer.android.google.cn/guide/topics/ui/controls/button.html\n\n## 文本字段 Specifying the Input Method Type\n\nhttps://developer.android.google.cn/training/keyboard-input/style.html\n\n## 复选框 Checkboxes\n\nhttps://developer.android.google.cn/guide/topics/ui/controls/checkbox.html\n\n## 单选按钮 Radio Buttons\n\nhttps://developer.android.google.cn/guide/topics/ui/controls/radiobutton.html\n\n## 切换按钮 Toggle Buttons\n\nhttps://developer.android.google.cn/guide/topics/ui/controls/togglebutton.html\n\n## 微调框\n\nhttps://developer.android.google.cn/guide/topics/ui/controls/spinner.html\n\n## 选取器\n\nhttps://developer.android.google.cn/guide/topics/ui/controls/pickers.html\n\n## 输入事件\n\nhttps://developer.android.google.cn/guide/topics/ui/ui-events.html\n\n## 菜单\n\nhttps://developer.android.google.cn/guide/topics/ui/menus.html\n\n## 设置\n\nhttps://developer.android.google.cn/guide/topics/ui/settings.html\n\n## 对话框\n\nhttps://developer.android.google.cn/guide/topics/ui/dialogs.html\n\n## 通知\n\nhttps://developer.android.google.cn/guide/topics/ui/notifiers/notifications.html\n\n## Toasts\n\nhttps://developer.android.google.cn/guide/topics/ui/notifiers/toasts.html\n\n## 搜索 Search Overview\n\nhttps://developer.android.google.cn/guide/topics/search/index.html\n\n## 创建搜索界面 Creating a Search Interface\n\nhttps://developer.android.google.cn/guide/topics/search/search-dialog.html\n\n## 添加近期查询建议 Adding Recent Query Suggestions\n\nhttps://developer.android.google.cn/guide/topics/search/adding-recent-query-suggestions.html\n\n## 添加自定义建议 Adding Custom Suggestions\n\nhttps://developer.android.google.cn/guide/topics/search/adding-custom-suggestions.html\n\n## 可搜索配置 Searchable Configuration\n\nhttps://developer.android.google.cn/guide/topics/search/searchable-config.html\n\n## 多窗口支持\n\nhttps://developer.android.google.cn/guide/topics/ui/multi-window.html\n\n## 拖放\n\nhttps://developer.android.google.cn/guide/topics/ui/drag-drop.html\n\n## 无障碍功能 Accessibility\n\nhttps://developer.android.google.cn/guide/topics/ui/accessibility/index.html\n\n## 为应用设置无障碍功能 Making Apps More Accessible\n\nhttps://developer.android.google.cn/guide/topics/ui/accessibility/apps.html\n\n## 无障碍功能开发者检查单 Accessibility Developer Checklist\n\nhttps://developer.android.google.cn/guide/topics/ui/accessibility/checklist.html\n\n## 构建无障碍服务 Building Accessibility Services\n\nhttps://developer.android.google.cn/guide/topics/ui/accessibility/services.html\n\n## 样式和主题\n\nhttps://developer.android.google.cn/guide/topics/ui/themes.html\n\n## 自定义组件 Custom Components\n\nhttps://developer.android.google.cn/guide/topics/ui/custom-components.html\n\n## 动画和图形 Animation and Graphics\n\nhttps://developer.android.google.cn/guide/topics/graphics/index.html\n\n## 概览 Overview\n\nhttps://developer.android.google.cn/guide/topics/graphics/overview.html\n\n## 属性动画 Property Animation\n\nhttps://developer.android.google.cn/guide/topics/graphics/prop-animation.html\n\n## 视图动画 View Animation\n\nhttps://developer.android.google.cn/guide/topics/graphics/view-animation.html\n\n## 可绘制动画 Drawable Animation\n\nhttps://developer.android.google.cn/guide/topics/graphics/drawable-animation.html\n\n## 画布和可绘制对象 Canvas and Drawables\n\nhttps://developer.android.google.cn/guide/topics/graphics/2d-graphics.html\n\n## OpenGL ES\n\nhttps://developer.android.google.cn/guide/topics/graphics/opengl.html\n\n## 硬件加速 Hardware Acceleration\n\nhttps://developer.android.google.cn/guide/topics/graphics/hardware-accel.html\n\n## 计算 Computation\n\nhttps://developer.android.google.cn/guide/topics/renderscript/index.html\n\n## RenderScript\n\nhttps://developer.android.google.cn/guide/topics/renderscript/compute.html\n\n## 高级 RenderScript\n\nhttps://developer.android.google.cn/guide/topics/renderscript/advanced.html\n\n## Runtime API 参考\n\nhttps://developer.android.google.cn/guide/topics/renderscript/reference/overview.html\n\n## 媒体和相机 Media and Camera\n\nhttps://developer.android.google.cn/guide/topics/media/index.html\n\n## 媒体回放 MediaPlayer\n\nhttps://developer.android.google.cn/guide/topics/media/mediaplayer.html\n\n## 媒体路由器 MediaRouter API\n\nhttps://developer.android.google.cn/guide/topics/media/mediarouter.html\n\n## 媒体路由提供程序 Media Route Provider API\n\nhttps://developer.android.google.cn/guide/topics/media/mediarouteprovider.html\n\n## ExoPlayer\n\nhttps://developer.android.google.cn/guide/topics/media/exoplayer.html\n\n## 支持的媒体格式 Supported Media Formats\n\nhttps://developer.android.google.cn/guide/topics/media/media-formats.html\n\n## 音频采集 MediaRecorder\n\nhttps://developer.android.google.cn/guide/topics/media/mediarecorder.html\n\n## 相机 Camera API\n\nhttps://developer.android.google.cn/guide/topics/media/camera.html\n\n## 位置和传感器 Location and Sensors APIs\n\nhttps://developer.android.google.cn/guide/topics/sensors/index.html\n\n## 位置和地图 Location and Maps\n\nhttps://developer.android.google.cn/guide/topics/location/index.html\n\n## 位置策略 Location Strategies\n\nhttps://developer.android.google.cn/guide/topics/location/strategies.html\n\n## 传感器概览 Sensors Overview\n\nhttps://developer.android.google.cn/guide/topics/sensors/sensors_overview.html\n\n## 运动传感器 Motion Sensors\n\nhttps://developer.android.google.cn/guide/topics/sensors/sensors_motion.html\n\n## 位置传感器 Position Sensors\n\nhttps://developer.android.google.cn/guide/topics/sensors/sensors_position.html\n\n## 环境传感器 Environment Sensors\n\nhttps://developer.android.google.cn/guide/topics/sensors/sensors_environment.html\n\n## 连接 Connectivity\n\nhttps://developer.android.google.cn/guide/topics/connectivity/index.html\n\n## 蓝牙\n\nhttps://developer.android.google.cn/guide/topics/connectivity/bluetooth.html\n\n## 蓝牙低功耗 Bluetooth Low Energy\n\nhttps://developer.android.google.cn/guide/topics/connectivity/bluetooth-le.html\n\n## NFC\n\nhttps://developer.android.google.cn/guide/topics/connectivity/nfc/index.html\n\n## NFC 基础知识 NFC Basics\n\nhttps://developer.android.google.cn/guide/topics/connectivity/nfc/nfc.html\n\n## 高级 NFC Advanced NFC\n\nhttps://developer.android.google.cn/guide/topics/connectivity/nfc/advanced-nfc.html\n\n## 基于主机的卡模拟 Host-based Card Emulation\n\nhttps://developer.android.google.cn/guide/topics/connectivity/nfc/hce.html\n\n## Wi-Fi P2P\n\nhttps://developer.android.google.cn/guide/topics/connectivity/wifip2p.html\n\n## USB\n\nhttps://developer.android.google.cn/guide/topics/connectivity/usb/index.html\n\n## 配件 USB Accessory\n\nhttps://developer.android.google.cn/guide/topics/connectivity/usb/accessory.html\n\n## 主机 USB Host\n\nhttps://developer.android.google.cn/guide/topics/connectivity/usb/host.html\n\n## SIP Session Initiation Protocol\n\nhttps://developer.android.google.cn/guide/topics/connectivity/sip.html\n\n## 文本和输入 Text and Input\n\nhttps://developer.android.google.cn/guide/topics/text/index.html\n\n## 复制和粘贴 Copy and Paste\n\nhttps://developer.android.google.cn/guide/topics/text/copy-paste.html\n\n## 创建 IME Creating an Input Method\n\nhttps://developer.android.google.cn/guide/topics/text/creating-input-method.html\n\n## 拼写检查程序 Spelling Checker Framework\n\nhttps://developer.android.google.cn/guide/topics/text/spell-checker-framework.html\n\n## 数据存储 Data Storage\n\nhttps://developer.android.google.cn/guide/topics/data/index.html\n\n## 存储选项\n\nhttps://developer.android.google.cn/guide/topics/data/data-storage.html\n\n## 数据备份 Backing up App Data to the Cloud\n\nhttps://developer.android.google.cn/guide/topics/data/backup.html\n\n## 应用安装位置 App Install Location\n\nhttps://developer.android.google.cn/guide/topics/data/install-location.html\n\n## Android 库\n\nhttps://developer.android.google.cn/topic/libraries/index.html\n\n## 支持库\n\nhttps://developer.android.google.cn/topic/libraries/support-library/index.html\n\n## 功能\n\nhttps://developer.android.google.cn/topic/libraries/support-library/features.html\n\n## 设置\n\nhttps://developer.android.google.cn/topic/libraries/support-library/setup.html\n\n## 修订历史记录 Recent Support Library Revisions\n\nhttps://developer.android.google.cn/topic/libraries/support-library/revisions.html\n\n## 数据绑定库 Data Binding Library\n\nhttps://developer.android.google.cn/topic/libraries/data-binding/index.html\n\n## 测试支持库\n\nhttps://developer.android.google.cn/topic/libraries/testing-support-library/index.html\n\n## 管理 Administration\n\nhttps://developer.android.google.cn/guide/topics/admin/index.html\n\n## 设备政策 Device Administration\n\nhttps://developer.android.google.cn/guide/topics/admin/device-admin.html\n\n## 网络应用 Web Apps\n\nhttps://developer.android.google.cn/guide/webapps/index.html\n\n## 在网络应用中支持不同屏幕 Supporting Different Screens in Web Apps\n\nhttps://developer.android.google.cn/guide/webapps/targeting.html\n\n## 在 WebView 中构建网络应用 Building Web Apps in WebView\n\nhttps://developer.android.google.cn/guide/webapps/webview.html\n\n## 迁移到 Android 4.4 中的 WebView Migrating to WebView in Android 4.4\n\nhttps://developer.android.google.cn/guide/webapps/migrating.html\n\n## 调试网络应用 Debugging Web Apps\n\nhttps://developer.android.google.cn/guide/webapps/debugging.html\n\n## 网络应用最佳做法 Best Practices for Web Apps\n\nhttps://developer.android.google.cn/guide/webapps/best-practices.html\n\n## 最佳实践 Best Practices\n\nhttps://developer.android.google.cn/guide/practices/index.html\n\n## 支持多种屏幕\n\nhttps://developer.android.google.cn/guide/practices/screens_support.html\n\n## 分配到特定屏幕 Distributing to Specific Screens\n\nhttps://developer.android.google.cn/guide/practices/screens-distribution.html\n\n## 屏幕兼容性模式 Screen Compatibility Mode\n\nhttps://developer.android.google.cn/guide/practices/screen-compat-mode.html\n\n## 支持平板电脑和手机 Supporting Tablets and Handsets\n\nhttps://developer.android.google.cn/guide/practices/tablets-and-handsets.html\n\n"},{"title":"获取已安装应用的apk文件","url":"/2017/10/11/获取已安装APP的apk文件/","content":"###获取程序包名\n```cmd\nadb shell pm list packages\n```\n\n```\n$ adb shell pm list packages\npackage:android\npackage:cn.wps.moffice\npackage:com.android.backupconfirm\npackage:com.android.bluetooth\npackage:com.android.browser\npackage:com.android.calculator2\npackage:com.android.camera\npackage:com.android.certinstaller\npackage:com.android.contacts\n```\n###找到apk的位置\n```\nadb shell pm path com.tence01.mm\n```\n\n```\n$ adb shell pm path com.tence01.mm\npackage:/data/app/com.tence01.mm-1.apk\n```\n\n###取出apk\n```\nadb pull /data/app/com.tence01.mm-1.apk ~/apks\n```\n\n```\n$ adb pull /data/app/com.tence01.mm-1.apk ~/apks\n2407 KB/s (25567735 bytes in 10.370s)\n\n```","tags":["android"],"categories":["总结"]},{"title":"Android开发问题收集","url":"/2017/07/26/Android开发问题收集/","content":"### The APK file  does not exist on disk. Error while Installing APK\n> 清楚缓存 \n\n```\nrm -rfv ~/Library/Caches/AndroidStudio*\n```\n\n> 刷新gradle\n\n![refresh all gradle projects](https://i.stack.imgur.com/2KSyU.png)\n\n\n\n### java.lang.IllegalArgumentExceptio\n\n>该异常表示view没有添加到窗口管理器，通常是我们dismiss对话框的时候，activity已经不存在了，建议不要在非UI线程操作对话框。\n\n```\nif(!activity.isFinishing && dialog!=null && dialog.isShow()){\n\tdialog.dismiss();\n}\n```\n### android.view.WindowManager$BadTokenException\n\n>该异常表示不能添加窗口，通常是所要依附的view已经不存在导致的。\n\n>通常出现在耗时的操作结束之后显示dailog，但是此时activity已经结束了。\n\n```\nif(!activity.isFinishing && dialog!=null ){\n\tdialog.show();\n}\n```\n\n\n\n"},{"title":"Material简单使用","url":"/2017/07/21/Material简单使用/","content":"首先介绍下Android的各个位置的名称：\n![Android 谷歌md规范](https://developer.android.com/training/material/images/ThemeColors.png)\n\n可以看到，最上面的是状态栏，最下面的是导航栏。\n如果您想为状态栏设置颜色，你可以通过制定android:statusBarColor来定义状态栏颜色，默认情况下，Android：statusBarColor的颜色继承Android：colorPrimaryDark.\n\n   您也可自行将状态栏移到后侧。例如，您想在一个照片上以透明的方式显示状态栏，同时利用细微的深色渐变以确保白色状态图标仍保持可见。 如果要执行此操作，请将 android:statusBarColor 属性设置为 @android:color/transparent 并根据需要调整窗口标志。您也可以使用 Window.setStatusBarColor() 方法进行动画或淡出设置。\n   \n   \n   colorPrimaryDark（状态栏底色）：在风格 (styles) 或是主题 (themes) 里进行设定。\nApp bar 底色\n这个设定分为二，若你的 android app 仍是使用 actionbar ，则直接在风格 (styles) 或是主题 (themes) 里进行设定 colorPrimary 参数即可；\n可若是采用 toolbar 的话，则要在界面 (layout) 里面设定 toolbar 控件的 background 属性。\nnavigationBarColor（导航栏底色）：\n\n\n\n\ncolorPrimaryDark\n\n状态栏背景色。\n在 style 的属性中设置。\ntextColorPrimary\n\nApp bar 上的标题与更多菜单中的文字颜色。\n在 style 的属性中设置。\nApp bar 的背景色\n\nActionbar 的背景色设定在 style 中的 colorPrimary。\nToolbar 的背景色在layout文件中设置background属性。\ncolorAccent\n\n各控制元件(如：check box、switch 或是 radoi) 被勾选 (checked) 或是选定 (selected) 的颜色。\n在 style 的属性中设置。\ncolorControlNormal\n\n各控制元件的预设颜色。\n在 style 的属性中设置\nwindowBackground\n\nApp 的背景色。\n在 style 的属性中设置\nnavigationBarColor\n\n导航栏的背景色，但只能用在 API Level 21 (Android 5) 以上的版本\n在 style 的属性中设置"},{"title":"AndroidStudio常用的mac快捷键","url":"/2017/07/18/AndroidStudio常用的mac快捷键/"},{"title":"Studio减小APK体积","url":"/2017/07/18/Android Studio减小APK体积/","content":"## 1. ProGuard\nProguard可以删除无效的Java code来减小apk的体积\n## 2. Split Apk\n[Split Apk](https://developer.android.com/studio/build/configure-apk-splits.html)谷歌官方支持的，可以为根据设备密度和ABI创建特定的Apk包，大大减少每个apk的体积。\n## 3. ReDex\nFacebook开源维护的，压缩代码的同时，还可以提高性能\n## 4. ShrinkResources\n去除无效的资源文件，图片是apk体积的大户，减少图片资源，就能有效的减少apk体积。在build.gradle里面使用\n\n```gradle\nrelease {\n...\n  shrinkResources true\n...\n}\n```\n## 5. resConfigs\n当应用不需要支持多国语言的时候，可以通过resConfig去除无用的语言资源，例如下面的配置就只保留了中文和英文的语言资源：\n\n```gradle\ndefaultConfig {\n...\n  resConfigs \"en\", \"zh\"\n...\n}\n```\n**注意：**\n\n```gradle\nresConfigs \"hdpi\", \"xhdpi\", \"xxhdpi\", \"xxxhdpi\"\n```\n**已经在新版本中废弃了，代替方案是在Gradle中使用splits根据不同的ABI以及不同的屏幕密度分别打包**\n\n## 6. Vector Drawables\n尽量使用vector资源，因为Vector资源文件大小，会比图片的小很多\n## 7. WebP file\n使用WebP格式的图片资源，相比PNG和JPEG，WebP在保证质量的同时，压缩率更好。\n\n## 8. 优化图片资源\n可以使用TinyPNG, OptiPNG等压缩图片。\n"},{"title":"Studio常用技巧","url":"/2017/07/18/Android Studio常用技巧/","content":"\n## tools:attribute\n如果你想查看布局的文字效果，但是有不想运行ed时候显示出来，你就可以通过'tools:something=\"value\"'来实现，你要做的只有两点\n\n1. 在根布局中添加xmlns:tools=\"http://schemas.android.com/tools\"\n2. 在TextView中使用'tools:something=\"value\"'属性。\n\n\n ![tools：text](http://mmbiz.qpic.cn/mmbiz_gif/y5HvXaQmpqlia7kPokpRXdHO05FiakCnm6VWRu5pWIcABUibCsbUcBuHOhAGEfr19a4pL0bVdZobfdlUYOcibn14XQ/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n>以前都是每次都用Android：text=：=“text”查看效果，然后弄好了之后再去删\n\n## Extract Resource\n如果你在某个布局文件里面，直接使用了某个String或者某个dimen数值，你可以通过option+enter直接选择Extract String/Dimension Resource，将对应的String或者dimen加入到对应的String.xml 或者dimen.xml\n\n![Extract Resource](http://mmbiz.qpic.cn/mmbiz_gif/y5HvXaQmpqlia7kPokpRXdHO05FiakCnm61DjNxib4bEW2Lr8p3LvXeX3hrC2gUWibuSkhIp1Cb39DqqeoF6ceDicAQ/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n\n"},{"title":"Gradle实践","url":"/2017/07/06/Gradle实践/","content":"# gradle task示例\n```java\ntask compile << {\n    println \"Compiled\"\n}\ntask clean << {\n    println \"Clean\"\n}\n```\n### task之间相互依赖\n> compile.dependsOn  clean\n\n### 执行顺序\n```java\ncompile.mustRunAfter clean  //只有执行了clean执行之后就会执行compile\n```\n### 自定义Property\n```java\next.property1 = \"this is property1\"\next{\n\tproperty2 = \"this is property2\"\n}\n```\n### 依赖其他moudle\n```Gradle\ndependencies {\n\tcompile project(':library')\n}\n```\n### Gradle为每个moudle都会生成一个build.gradle，为了管理这些moudle，他还会在根目录下生成一个build.gradle\n\n![allprojexts配置](http://ww1.sinaimg.cn/large/d948997dgy1fha5q0bwtrj20hk09ggmv.jpg)\n\n**allprojects()方法将repositories配置一次性地应用于所有的module（子Project）和root-project本身，当然也包括定义的Task，这个task配置到所有module里面了和root-project。\nsubprojects()方法用于配置所有的子Project（不包含根Project）**\n###引入其他的Gradle文件的task\n``` gradle\napply from: '../nuild-config/build.gradle'\n```\n### 控制输出名称和路径\n```gradle\nandroid.applicationVariants.all { variant ->\n\n    variant.outputs.each { output ->\n        def outputFile = output.outputFile\n        if (outputFile != null && outputFile.name.endsWith('.apk')) {\n            def fileName = outputFile.name;\n            if (android.defaultConfig.versionName != null) {\n                fileName = fileName.replace(\".apk\", \"-${android.defaultConfig.versionName}.apk\")\n            }\n            if (project.hasProperty('OUT_PUT_APK_SUFFIX_PARA')) {\n                fileName = fileName.replace(\".apk\", \"-${OUT_PUT_APK_SUFFIX_PARA}.apk\")\n            }\n            def today = new Date().format('yyMMddHHmm');\n            fileName = fileName.replace(\".apk\", \"-${today}.apk\")\n            if (project.hasProperty('OUT_PUT_DIR_PARA')) {\n                File output_dir1 = file(\"${OUT_PUT_DIR_PARA}\");\n                output.outputFile = new File(output_dir1, fileName)\n                println \"输出文件位置： \" + output.outputFile\n                //}\n            } else {\n                output.outputFile = new File(outputFile.parent, fileName)\n                println \"输出文件位置： \" + output.outputFile\n            }\n        }\n    }\n}\n```\n\n###拼接字符串\n``` gradle\next.tem = 'tem'\ndef name = \"my name is $tem\"\n```\n\n## Gradle执行顺序\n### dependsOn\n**如果我们想执行的task A依赖于task B**\n\n```gradle\ntask A << {\n\tprintln \"Hello From A\"\n}\ntask B << {\n    println \"Hello From B\"\n}\nA.dependsOn B\n```\n```gradle\ntask A << {println 'Hello from A'}\ntask B {\n    dependsOn A\n    doLast {\n        println 'Hello from B'  \n    }\n}\n```\n这样我们执行Gradle B的时候就会先执行 A,上面两种写法的效果是一样的。\n\n> 如果我们想在已近存在task依赖中插入我们的task，改怎么办呢？\n\n```gradle\ntask A << {println 'Hello from A'}\ntask B << {println 'Hello from B'}\ntask C << {println 'Hello from C'}\nB.dependsOn A\nC.dependsOn B\n```\n**加入我们的新task**\n\n```gradle\ntask B1 << {println 'Hello from B1'}\nB1.dependsOn B\nC.dependsOn B1\n```\n执行Gradle c\n\n```gradle\npaveldudka$ gradle C\n:A\nHello from A\n:B\nHello from B\n:B1\nHello from B1\n:C\nHello from C\n```\n![插入依赖](http://static.oschina.net/uploads/img/201509/21084247_m1Nh.png)\n\n###mustRunAfter\n假设我们有三个task，其中一个依赖其他两个，代码如下：\n\n```gradle\ntask unit << {println 'Hello from unit tests'}\ntask ui << {println 'Hello from UI tests'}\ntask tests << {println 'Hello from all tests!'}\n\ntests.dependsOn unit\ntests.dependsOn ui\n```\n执行Gradle tests结果\n\n```gradle\npaveldudka$ gradle tests\n:ui\nHello from UI tests\n:unit\nHello from unit tests\n:tests\nHello from all tests!\n```\n**尽管unit和UI会在tests之前执行，但是UI和unit的执行顺序是不能保证的，虽然看起来是按照字母表的执行，但这依赖于Gradle的默认实现，我们也不清楚具体是怎样的规则，因此如果们有先后顺序的区分，我们就不能依赖这种顺序**\n\n**如果我希望unit先执行，然后子啊执行UI，一个解决办法就是UI依赖unit**\n\n```gradle\ntask unit << {println 'Hello from unit tests'}\ntask ui << {println 'Hello from UI tests'}\ntask tests << {println 'Hello from all tests!'}\n\ntests.dependsOn unit\ntests.dependsOn ui\nui.dependsOn unit\n```\n\n**但是有个问题，我们的UI task并不依赖于 unit ,每次执行UI task的时候都会执行unit，这就要用到 mustRunAfter了。这里指定 ui.mustRunAfter unit,这样如果UI和unit同事存在的时候，Gradle会先执行unit，他们也可以单独执行**\n\n###finalizedBy\n现在我们有UI和unit两个task，我们希望两个执行完了之后合并输出：\n\n```gradle\ntask unit << {println 'Hello from unit tests'}\ntask ui << {println 'Hello from UI tests'}\ntask tests << {println 'Hello from all tests!'}\ntask mergeReports << {println 'Merging test reports'}\n\ntests.dependsOn unit\ntests.dependsOn ui\nui.mustRunAfter unit\nmergeReports.dependsOn tests\n\n```\n**这个task是能工作，但是看起来好笨啊。mergeReports从用户的角度来看感觉不是特别好。我希望执行tests task就可以获得测试报告，而不必知道mergeReports的存在。当然我可以把merge的逻辑挪到tests task中，但我不想把tests task搞的太臃肿，我还是继续把merge的逻辑放在mergeReports task中。 \nfinalizeBy来救场了。顾名思义，finalizeBy就是在task执行完之后要执行的task。修改我们的脚本如下**\n\n```gradle\ntask unit << {println 'Hello from unit tests'}\ntask ui << {println 'Hello from UI tests'}\ntask tests << {println 'Hello from all tests!'}\ntask mergeReports << {println 'Merging test reports'}\n\ntests.dependsOn unit\ntests.dependsOn ui\nui.mustRunAfter unit\nmergeReports.dependsOn tests\ntests.finalizedBy mergeReports\n```\n现在执行tests task就可以拿到测试报告了：\n\n\n```gradle\npaveldudka$ gradle tests\n:unit\nHello from unit tests\n:ui\nHello from UI tests\n:tests\nHello from all tests!\n:mergeReports\nMerging test reports\n```\n\n\n\n\n","categories":["Gradle实践"]},{"title":"DL插件化实践","url":"/2017/07/05/DL插件化实践/","tags":["DL"],"categories":["插件化"]},{"title":"Android反编译","url":"/2017/04/06/Android反编译/","content":"\n工欲善其事必先利其器，反编译apk，首先我们需要必须的工具\n\n>* apktool\t\t\t\t\t\t\t\n* dex2jar\n* jd-gui\n* AXMLPrinter\n\n我做了一下整理，可以直接在这里下载所需的全部工具 [下载链接](http://pan.baidu.com/s/1i5mOe1J)\n\n\n### 工具介绍\n\n\n <font color=#ff0000 size=5 > apktool</font>\n \n 获取资源文件，比如图片或者布局XML文件\n \n <font color=#ff0000 size=5>dex2jar</font>\n \n 将class.dex文件转化成jar包\n \n <font color=#ff0000 size=5>jd-gui</font>\n \n 查看class.dex转化的jar包\n <font color=#ff0000 size=5>AXMLPrinter</font>\n \n 还原xml文件\n \n \n## 获取资源文件和XML文件\napktool获取资源文件：将aapt.exe,apktool.bat,apktool.jar 放到同一目录下，定位到apktool文件夹，运行一下命令：apktool.bat d -f test.apk test\n\n> apktool.bat d -f [apk文件] [输出的文件夹]\n\t\t\t\t\n![命令行](http://ww1.sinaimg.cn/large/d948997dgy1fed0rojzywj20it0bumx5.jpg)\n\n反编译之后会在apktool所在目录下新建一个文件夹，文件夹目录如下\n![文件夹目录](http://ww1.sinaimg.cn/large/d948997dgy1fed0sys3gyj20hj07pjr8.jpg)\n\n*如果发现反编译出来的都是smali文件，可能是你使用的是旧的apktool,建议去官方网址下载 [apktool官方下载网址](https://ibotpeaches.github.io/Apktool/)，也可以使用我已经打包好的全套文件[百度网盘下载](http://pan.baidu.com/s/1i5mOe1J)*\n\n\n## 获取Java源代码\n将apk文件更改后缀名为zip或者rar，解压之后目录如下：\n![解压后文件目录](http://ww1.sinaimg.cn/large/d948997dgy1fed10t94pyj20j50803yg.jpg)\n可以看到，目录下面包含多个.dex文件，一般的小项目都会只有一个.dex文件，我这个是以支付宝为例，项目比较多，进行了分包处理。\n\n*在命令行下定位到dex2jar.bat所在的目录，dex2jar [dex文件的路径]*\n![dex获取源码](http://ww1.sinaimg.cn/large/d948997dly1fed16hklqzj20it0buq2z.jpg)\n\n在dex所在的目录下会生成一个class_dex2jar.jar文件，运行jd-gui文件夹下的jd-gui.exe ,并且用改工具打开之前生成的class_dex2jar.jar文件就可以查看Java源码啦。\n![Java源码](http://ww1.sinaimg.cn/large/d948997dgy1fed1aqqimjj20s90jatbu.jpg)\n\n## 获取AndroidManifest.xml \n打开我们解压后的apk文件夹，你会发现 Android开发必须的 AndroidManifest.xml文件，打开文件：\n![AndroidManifest.xml](http://ww1.sinaimg.cn/large/d948997dgy1fed1cozh4aj20ub0d6gq7.jpg)\nwf,什么鬼，全是乱码。下面就要用到我们的AXMLPrinter工具来还原AndroidManifest.xml\n命令行定位到AAXMLPrinter2.jar所在目录，运行下面的命令：\n```\njava -jar AXMLPrinter2.jar AndroidManifest.xml > AndroidManifest2.txt\n```\n\n你会发现在AXMLPrinter2.jar目录下，会生成一个AndroidManifest2.txt，打开AndroidManifest2.txt发现我们能看懂了：\n![AndroidManifest文件](http://ww1.sinaimg.cn/large/d948997dly1fed1msw9qjj20uk0jgmxt.jpg)\n\n\n这就是本次与大家分享的Android反编译，希望对大家有用。\n\n\n\n\n\n\n\n\n\n\n","categories":["反编译"]},{"title":"Retrofit的简单封装","url":"/2017/03/20/retrofit/","content":"\n# 前言\n2016年，关于retrofit和okhttp这两个话题非常火，retrofit+okhhtp已经成为Android网络请求的主流框架了，看了一下现在公司的项目，还是使用的原始的HttpURLConnection，瞬间感觉有点low，通过自己的学习，决定对公司的网络请求进行一下改造，在这里做一下简单的总结，希望大家多多指正。\n\n# Retrofit\n  retrofit是一个基于okhttp的，适用于Android，Java的网络请求工具。我觉得它其实就是对okhttp做一下统一的封装，方便广大开发者的更快捷、更方便的使用。如果你对retrofit还不是很熟悉，可以去[Retrofit官网](http://square.github.io/retrofit/)了解下，我也会在接下来做个简单的使用说明。它既然这么火，而且已经进行很好的封装了，但是我们为什么还要对它封装呢？因为每个公司的业务不一样，这个框架大而且全，其实很多在我们的业务里面根本使用不到，所以我们需要个性化定制。\n  \n1. 首先创建一个网络请求API的Interface\t\n\t\n\t```java\n\tpublic interface GitHubService {\n  \t\t@GET(\"users/{user}/repos\")\n  \t\tCall<List<Repo>> listRepos(@Path(\"user\") String user);\n\t}\n\n\t```\n2. 初始化Retrofit,并创建一个GitHubService interface\n\n\t```\n\tRetrofit retrofit = new Retrofit.Builder()\n    .baseUrl(\"https://api.github.com/\")\n    .build();\n\n\tGitHubService service = retrofit.create(GitHubService.class);\n\t```\t\n\t\n\t\n3. 对GitHubService的方法进行同步或者一部的访问，来实现网络的请求(使用enqueue 或者 execute来执行发起请求，enqueue是是异步执行，而 execute是同步执行)\n\t```\n\tCall<List<Repo>> repos = service.listRepos(\"octocat\");\n\t```\n\n上面就是官网对retrofit的简单讲解，下面就进行我们的简单封装。\n# Interface的改造\n因为公司的网络请求都是在common包里面处理的，而和这个包是不会经常改动的，但是每次增加一个求情，都要改动一下common包里面的网络请求的Interface，这个不利于模块的解耦。下面是我对Interface的改造：\t\n\n```java\npublic interface NetInterface {\n    @GET\n    Call get(@Url String url);\n\n    @POST\n    Call post(@Url String url, @Body RequestBody body);\n\n    @Multipart\n    @POST\n    Call updateFile(@Url String url, @Part MultipartBody.Part file, @PartMap HashMap<String, RequestBody> map);\n}\n```\n\n![Interface改造](http://ww1.sinaimg.cn/large/d948997dgy1fduncamc8lj21em0bcmzd.jpg)\n\n定义了三个方法，get、post、updateFile对应网络请求的GET、POST和文件上传，这样每次就只需传入一个url就可以进行网络请求，不用每次都去更改。\n\n# Retrofit的封装NetUtils\n``` java\npublic class NetUtils {\n    private static NetUtils INSTANCE;\n    private OkHttpClient mClient;\n    private Retrofit mRetrofit;\n    private ArrayList<Call> callLists=new ArrayList<>();\n\n    private NetUtils() {\n        OkHttpClient.Builder builder = new OkHttpClient.Builder();\n        builder.connectTimeout(15, TimeUnit.SECONDS);\n        builder.addInterceptor(new NetInterceptor());\n        mClient = builder.build();\n        mRetrofit = new Retrofit.Builder()\n                .baseUrl(\"\")\n                .addConverterFactory(FastjsonConverterFactory.create())\n                .client(mClient)\n                .build();\n    }\n\n    public static NetUtils getInstance() {\n        if (INSTANCE == null) {\n            synchronized (NetUtils.class) {\n                if (INSTANCE == null) {\n                    INSTANCE = new NetUtils();\n                }\n            }\n        }\n        return INSTANCE;\n    }\n\n\n    public Call get(String url) {\n        return mRetrofit.create(NetInterface.class).get(url);\n    }\n\n\n    public Call post(String url, FormBody body) {\n        return mRetrofit.create(NetInterface.class).post(url, body);\n    }\n\n    public Call updateFile(String url, MultipartBody.Part file, HashMap<String, RequestBody> body) {\n        return mRetrofit.create(NetInterface.class).updateFile(url, file, body);\n    }\n\n}\n```\n在这里，可以设置缓存，设置统一的网络拦截器……，我这边写的都比较简单\n\n```java\npublic class NetInterceptor implements Interceptor {\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n\n        Response respone = chain.proceed(chain.request());\n        Log.d(\"TAG\", respone.request().url() + \"\");\n        Log.d(\"TAG\", respone.body() + \"\");\n        return respone;\n    }\n}\t\n```\n简单的打印url，也可以在这里添加一些通用的参数\n![NetInterceptor](http://ww1.sinaimg.cn/large/d948997dgy1fdup4d3ficj20vu0b440c.jpg)\n\t\n# 请求工具类NetLoader\n```java\npublic class NetLoader {\n    private ArrayList<Call> callList = new ArrayList<>();\n    private HashMap<String, Call> callMap = new HashMap<>();\n    private String TAG = \"TAG\";\n\n    public Call get(String url, Callback callback) {\n        Call call = NetUtils.getInstance().get(url);\n        call.enqueue(callback);\n        callList.add(call);\n        return call;\n    }\n\n    public Call get(String url, String tag, Callback callback) {\n        Call call = NetUtils.getInstance().get(url);\n        callList.add(call);\n        return call;\n    }\n\n    public Call post(String url, String postStr, Callback callback) {\n        FormBody.Builder builder = new FormBody.Builder();\n        String[] maps = postStr.split(\"&\");\n        for (String s : maps) {\n            String key = s.substring(0, s.indexOf(\"=\"));\n            String value = s.substring(s.indexOf(\"=\") + 1, s.length());\n            builder.add(key, value);\n        }\n        Call call = NetUtils.getInstance().post(url, builder.build());\n        call.enqueue(callback);\n        callList.add(call);\n        return call;\n\n    }\n    public Call updateFile(String url, String postStr, String fileKey, File file, Callback callback) {\n        HashMap<String, RequestBody> map = new HashMap<>();\n        String[] maps = postStr.split(\"&\");\n        for (String s : maps) {\n            String key = s.substring(0, s.indexOf(\"=\"));\n            String value = s.substring(s.indexOf(\"=\") + 1, s.length());\n            RequestBody body = RequestBody.create(MediaType.parse(\"text/plain\"), value);\n            map.put(key, body);\n\n        }\n        RequestBody requestFile =\n                RequestBody.create(MediaType.parse(\"multipart/form-data\"), file);\n        MultipartBody.Part body =\n                MultipartBody.Part.createFormData(fileKey, file.getName(), requestFile);\n\n        Call call = NetUtils.getInstance().updateFile(url, body, map);\n        call.enqueue(callback);\n        callList.add(call);\n        return call;\n    }\n\n\n    public void destroy() {\n        for (Call call : callList) {\n            call.cancel();\n        }\n    }\n\n    public void removeCall(Call call) {\n        callList.remove(call);\n    }\n\n}\n```\n其实上面的NetUtils已经满足了我们的网络请求，为什么还要把它包装到NetLoader里面呢？原因是为了我们\n我们可以通过在每个Activity或者Fragment里面新建一个netLoader示例，在destroy方法里面调用netloader. destroy()方法，就可以实现与之周期进行绑定，防止异常。\n# CallBack的封装\n我们还可以对请求返回的callback就行同意的处理：\n\n```java\npublic class NetCallBack implements Callback {\n    private WeakReference<Context> reference;\n    public NetCallBack(Context context){\n        reference=new WeakReference<Context>(context);\n    }\n\n    @Override\n    public void onResponse(Call call, Response response) {\n        if(response.body()==null){\n            Toast.makeText(reference.get(), \"返回为空\", Toast.LENGTH_SHORT).show();\n        }else{\n            //TODO 其他的一些判断,如登陆或者其他的统一操作\n\n        }\n    }\n\n    @Override\n    public void onFailure(Call call, Throwable t) {\n        Toast.makeText(reference.get(), \"网络连接错误\", Toast.LENGTH_SHORT).show();\n    }\n\n}\n```\n当网络请求失败的时候，我们可以统一的弹窗处理，当用户没登录时，我们可以自己跳到登录页……\n\n*以上就是我对网络请求的简单封装，欢迎大家向我吐槽！*\n\n\n\n\n\n","tags":["封装"],"categories":["Retrofit"]},{"title":"MarkDown的基本用法","url":"/2017/03/16/MarkDown/","content":"  最近准备弄个自己的博客，记录整理一下自己的学习过程。MarkDown作为一种标记语言，简单易上手，而且比较流行的博客都对MarkDown有很好的支持，所以记录一下MarkDown的简单用户，方便在以后的学习中，能刚快的上手。\n\n# 设置头部\n```bash\n# Header 1\n## Header 2\n### Header 3\n#### Header 4\n##### Header 5\n###### Header 6\n\n```\n \n<font color=#ff0000 size=3>效果</font>\n\n## Header 2\n### Header 3\n#### Header 4\n##### Header 5\n###### Header 6\n\t\n\t\n\t\t\t\t\n\t\t\t\t\n# 无序列表（<font color=#ff0000 size=3>注意缩进</font>）\n\n``` bash\n*  第一列\n * 第二列\n * 第三列\n  * 第四列\n```\n\n<font color=#ff0000 size=3>效果</font>\n\n* 第一列\n* 第二列\n* 第三列\n  * 第四列\n\n# 有序列表\n\n```\n1. 第一列\n2. 第二列\n3. 第三列\n```\n### <font color=#ff0000 size=3>效果</font>\n1. 第一列\n2. 第二列\n3. 第三列\n4. 第四列\n\n\n# 引用\n\n```\n> 第一列\n> 第二列\n> 第三列\n```\n### <font color=#ff0000 size=3>引用效果</font>\n> 第一列\t\n> 第二列\t\n> 第三列\t\n\n# 嵌套列表\n\n```\n- 列表1\n\t+ 列表2\n\t+ 列表3\n\t\t+ 列表8\n- 列表4\n\t+  列表5\n\t+  列表6\n```\n### <font color=#ff0000 size=3>嵌套列表效果</font>\n- 列表1\n\t+ 列表2\n\t+ 列表3\n\t\t+ 列表8\n- 列表4\n\t+  列表5\n\t+  列表6\n\n\n# 文字链接\n\n```\n[百度一下](https://www.baidu.com \"百度一下\")\n```\n### <font color=#ff0000 size=3>文字链接效果</font>\n[百度一下](https://www.baidu.com \"百度一下\")\n\n> 前面的百度一下表示展示文字\t\n> 后面的百度一下指当鼠标在文字上面的时候显示的内容 \n\n\n# 图片链接\n\n```\n![测试](http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png \"GitHub Mark\")\n```\n### <font color=#ff0000 size=3>图片链接效果</font>\n\n![测试](http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png \"GitHub Mark\")\n> 前面的测试指图片的名称  \n> 后面的github mark指鼠标放在图片上展示的内容\n\n\n# 自动链接\n\n```\n<854350705@qq.com>\n<https:www.baidu.com>\n```\n### <font color=#ff0000 size=3>自动链接效果</font>\n<854350705@qq.com>\t\n<https:www.baidu.com>\n\n\n# 代码\n\n```\n用``` ```包裹\n或者每行文字4个空格或者1个TAB\n```\n### <font color=#ff0000 size=3>代码效果</font>\n\n``` java\nString a=\"a\";\nString b = \"b\";\npriintln(a+b);\n```\n\n\tString a=\"a\";\n\tString a=\"a\";\n\tString a=\"a\";\n\n#注释\n\n```\n<!-- 注释 -->\n```\n<!-- 注释 -->\n\n# 转义字符\n\n```\n\\\\ 反斜杠\n\\` 反引号\n\\* 星号\n\\_ 下划线\n\\{\\} 大括号\n\\[\\] 中括号\n\\(\\) 小括号\n\\# 井号\n\\+ 加号\n\\- 减号\n\\. 英文句号\n\\! 感叹号\n```\n### <font color=#ff0000 size=3>转义效果（每个字符前添加\\）</font>\n\\\\ 反斜杠\n\n\\` 反引号\n\n\\* 星号\n\n\\_ 下划线\n\n\\{\\} 大括号\n\n\\[\\] 中括号\n\n\\(\\) 小括号\n\n\\# 井号\n\n\\+ 加号\n\n\\- 减号\n\n\\. 英文句号\n\n\\! 感叹号\n\n# 表格\n\n```\n| 列1        | 列2           |列3 |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n```\n\n### <font color=#ff0000 size=3>表格效果</font>\n| 列1        | 列2           |列3 |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n\n# 设置字体大小颜色\n\n```\n### <font color=#ff0000 face=\"微软雅黑\" size=12> 表格效果</font>\n```\n\n### <font color=#ff0000 face=\"微软雅黑\" size=3> 设置字体大小颜色效果</font>\n\n# 行内标签\n\n```\n快捷键 `Ctrl + D` 来收藏本页\n```\n### <font color=#ff0000 size=3> 行内标签效果</font>\n快捷键 `Ctrl + D` 来收藏本页\n\n#html标签\n<table>\n    <tr>\n        <th rowspan=\"2\">值班人员</th>\n        <th>星期一</th>\n        <th>星期二</th>\n        <th>星期三</th>\n    </tr>\n    <tr>\n        <td>李强</td>\n        <td>张明</td>\n        <td>王平</td>\n    </tr>\n</table>\n\n\t\t\t\n\t\t\t\n#参考式链接\n\t\n\n```\n我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]\n[Leanote 笔记][2]是一个不错的[网站][]。\n[1]:http://www.google.com \"Google\"\n[2]:http://www.leanote.com \"Leanote\"\n[3]:http://http://blog.leanote.com/freewalk \"梵居闹市\"\n[网站]:http://http://blog.leanote.com/freewalk\n```\n我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]\n[Leanote 笔记][2]是一个不错的[网站][]。\n[1]:http://www.google.com \"Google\"\n[2]:http://www.leanote.com \"Leanote\"\n[3]:http://http://blog.leanote.com/freewalk \"梵居闹市\"\n[网站]:http://http://blog.leanote.com/freewalk\n\t\t\t\n\t\t\n\t\t\n\t\t\n#包含段落的列表\n\n\n> 必须缩进4个空格或者1个TAB\n\n<span id = \"jump\">跳转到这里：</span>\n\n[说明文字](#jump)\n\n# 文字加粗\n```\n **加粗内容**\n```\n **加粗内容**\n# 文字斜体\n```\n_斜体_\n\n```\n _斜体_\n","tags":["MarkDown"],"categories":["实用工具"]},{"title":"hexo使用","url":"/2017/03/15/hexo/","content":"\n1. 安装hexo\n ```\n$ npm install -g hexo-cli\n``` \n2. 初始化hexo\n```\n$ hexo init <folder>\n$ cd <folder>\n$ npm install\n``` \n目录结构如下\n```\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n |   ├── _drafts\n |   └── _posts\n└── themes\n```  \n\n","categories":["hexo"]},{"title":"Hello World","url":"/2017/03/15/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"},{"title":"Android常用工具类","url":"/2017/03/14/AndroidUtils/","content":"\n##获取资源\n###根据id获取资源\n``` java\ngetResources().getDrawable(id); //通过资源id获取drawable\n```\n###根据名称和类别获取资源\n``` java\ngetResources().getIdentifier(\"ic_launcher\", \"drawable\", getPackageName())\n```\n###String判空\n``` java\nTextUtils.isEmpty(CharSequence str)\n```\n###富文本显示\n``` java\nHtml.fromHtml()\n```\n输入一段html,就可以实现比较复杂的富文本展示\n\n###view 自动点击\n```\nview.performClick()\n```\n###设置ScrollView是否填满屏幕\n```java\nandroid:fillViewport\n```  \n\n","tags":["工具"],"categories":["工具"]},{"title":"UML使用","url":"/2016/12/07/UML/","content":"\n>UML（Unified Modeling Language）中文统一建模语言，是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。 【维基百科】\n\n最近做的项目，感觉项目越来越大，其中的关系也变得越来越复杂，急需理清其中的相关联系，所以就整理一下UML使用技巧，希望自己通过UML，能够理清自己的思路。\n\n##类图作用\n类图是软件工程的统一建模语言一种静态结构图，该图描述了系统的类集合，类的属性和类之间的关系。帮助人们简化对系统的理解，它是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。学习好类图的绘制，是一位合格的软件工程师应有的技能。\n##类图的示例\n类主要包括类名、属性和方法以及方法所需的参数，用类图简单的表示如下图所示：\n![Alt Image Text](https://dn-myg6wstv.qbox.me/583a2a5821869b32a480 \"图1\")\nJava中，可见性分为三类：private、public、protexted,分别用-，+和#来表示。\n###类名\n对于Java中的类名，如果是抽象类的haunted，在类名的右下角会有一个（Abstarct）表示。\n###属性\n属性的一般表示格式为：\n```\n可见性  名称:类型 [ = 默认值 ]\n```\n如：+ name:String =zhoujunpeng\n\n###方法\n方法的表示格式为：\n```\n可见性  名称(参数列表) [ : 返回类型]\n```\n如：\n> * + setName(String name) : void\n>* + getName() :String;\n\n##类与之间的关系\n###泛化(Generalization)关系\n泛化关系是指java中的继承，类和类，接口和接口之间的继承关系，一般用实线和带空心的三角形表示，如下图：\n![泛化关系](https://dn-myg6wstv.qbox.me/9e4b61c4ea01063fd435)\n###实现（Realization)关系\n实现关系是指类与接口之间的关系，一般用虚线和带空心的三角形表示，如下图：\n![泛化关系](https://dn-myg6wstv.qbox.me/1acef76e05fa49640207)\n###依赖(Dependence)关系\n依赖关系可以理解为一个类使用了另外一个类，一般用带箭头的虚线表示，如图：\n\n![泛化关系](https://dn-myg6wstv.qbox.me/7f1190bf98428711c3b3)\n\n###关联（Association）关系\n关联是指一个类和另外一个类有联系，一般用带箭头的实线表示，箭头指向被包含的类，如图：\n![泛化关系](https://dn-myg6wstv.qbox.me/1a67696c06b815f47f29)\n\n线上的标志表示：\n>\n* 1..1 表示另一个类的一个对象只与该类的一个对象有关系\n* 0..* 表示另一个类的一个对象与该类的零个或多个对象有关系\n* 1..* 表示另一个类的一个对象与该类的一个或多个对象有关系\n* 0..1 表示另一个类的一个对象没有或只与该类的一个对象有关系\n* 任意多个对象关联\n\n###聚合(Aggregation)关系\n聚合表示整体与部分的关系，而且部分可以脱离整体二存在，一般用带空心菱形的直线表示，如图：\n![泛化关系](https://dn-myg6wstv.qbox.me/f513265ce32b0dfc9d80)\n\n###组合(Composition)关系\n组合关系也是一种部分和整体的关系，但是部分存活周期受到整体的影响，若整体不存在则部分也将不存在。此时部分需在整体的构造方法中创建。在UML类中，组合关系用带实心菱形的直线表示。\n![泛化关系](https://dn-myg6wstv.qbox.me/e2316ce0dd180db8fe8d)\n\n##最后看下完整的类图展示\n![泛化关系](https://dn-myg6wstv.qbox.me/143f47fc3ae1e1acd759)"},{"title":"RxJava2操作符用法示例","url":"/2016/12/07/RxJava2 example/","content":"\n#RxJava2\n*SimpleExample*\n\n```\nObservable.just(\"Cricket\", \"Football\")..subscribeOn(Schedulers.io())\n                // Be notified on the main thread\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Observer<String>() {\n\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.d(TAG, \" onSubscribe : \" + d.isDisposed());\n            }\n\n            @Override\n            public void onNext(String value) {\n                textView.append(\" onNext : value : \" + value);\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onNext : value : \" + value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                textView.append(\" onError : \" + e.getMessage());\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onError : \" + e.getMessage());\n            }\n\n            @Override\n            public void onComplete() {\n                textView.append(\" onComplete\");\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onComplete\");\n            }\n        });\n```\n逐行打印出数据********\n\nmap操作****\n\n```\n/*\n    * Here we are getting ApiUser Object from api server\n    * then we are converting it into User Object because\n    * may be our database support User Not ApiUser Object\n    * Here we are using Map Operator to do that\n    */\n /*\n    * Here we are getting ApiUser Object from api server\n    * then we are converting it into User Object because\n    * may be our database support User Not ApiUser Object\n    * Here we are using Map Operator to do that\n    */\n    private void doSomeWork() {\n        getObservable()\n                // Run on a background thread\n                .subscribeOn(Schedulers.io())\n                // Be notified on the main thread\n                .observeOn(AndroidSchedulers.mainThread())\n                .map(new Function<List<ApiUser>, List<User>>() {\n\n                    @Override\n                    public List<User> apply(List<ApiUser> apiUsers) throws Exception {\n                        return Utils.convertApiUserListToUserList(apiUsers);\n                    }\n                })\n                .subscribe(getObserver());\n    }\n\n    private Observable<List<ApiUser>> getObservable() {\n        return Observable.create(new ObservableOnSubscribe<List<ApiUser>>() {\n            @Override\n            public void subscribe(ObservableEmitter<List<ApiUser>> e) throws Exception {\n                if (!e.isDisposed()) {\n                    e.onNext(Utils.getApiUserList());\n                    e.onComplete();\n                }\n            }\n        });\n    }\n\n    private Observer<List<User>> getObserver() {\n        return new Observer<List<User>>() {\n\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.d(TAG, \" onSubscribe : \" + d.isDisposed());\n            }\n\n            @Override\n            public void onNext(List<User> userList) {\n                textView.append(\" onNext\");\n                textView.append(AppConstant.LINE_SEPARATOR);\n                for (User user : userList) {\n                    textView.append(\" firstName : \" + user.firstName);\n                    textView.append(AppConstant.LINE_SEPARATOR);\n                }\n                Log.d(TAG, \" onNext : \" + userList.size());\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                textView.append(\" onError : \" + e.getMessage());\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onError : \" + e.getMessage());\n            }\n\n            @Override\n            public void onComplete() {\n                textView.append(\" onComplete\");\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onComplete\");\n            }\n        };\n    }\n```\nzip****\n\n```\n/*\n    * Here we are getting two user list\n    * One, the list of cricket fans\n    * Another one, the list of football fans\n    * Then we are finding the list of users who loves both\n    */\n    private void doSomeWork() {\n        Observable.zip(getCricketFansObservable(), getFootballFansObservable(),\n                new BiFunction<List<User>, List<User>, List<User>>() {\n                    @Override\n                    public List<User> apply(List<User> cricketFans, List<User> footballFans) throws Exception {\n                        return Utils.filterUserWhoLovesBoth(cricketFans, footballFans);\n                    }\n                })\n                // Run on a background thread\n                .subscribeOn(Schedulers.io())\n                // Be notified on the main thread\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(getObserver());\n    }\n\n    private Observable<List<User>> getCricketFansObservable() {\n        return Observable.create(new ObservableOnSubscribe<List<User>>() {\n            @Override\n            public void subscribe(ObservableEmitter<List<User>> e) throws Exception {\n                if (!e.isDisposed()) {\n                    e.onNext(Utils.getUserListWhoLovesCricket());\n                    e.onComplete();\n                }\n            }\n        });\n    }\n\n    private Observable<List<User>> getFootballFansObservable() {\n        return Observable.create(new ObservableOnSubscribe<List<User>>() {\n            @Override\n            public void subscribe(ObservableEmitter<List<User>> e) throws Exception {\n                if (!e.isDisposed()) {\n                    e.onNext(Utils.getUserListWhoLovesFootball());\n                    e.onComplete();\n                }\n            }\n        });\n    }\n\n    private Observer<List<User>> getObserver() {\n        return new Observer<List<User>>() {\n\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.d(TAG, \" onSubscribe : \" + d.isDisposed());\n            }\n\n            @Override\n            public void onNext(List<User> userList) {\n                textView.append(\" onNext\");\n                textView.append(AppConstant.LINE_SEPARATOR);\n                for (User user : userList) {\n                    textView.append(\" firstName : \" + user.firstName);\n                    textView.append(AppConstant.LINE_SEPARATOR);\n                }\n                Log.d(TAG, \" onNext : \" + userList.size());\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                textView.append(\" onError : \" + e.getMessage());\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onError : \" + e.getMessage());\n            }\n\n            @Override\n            public void onComplete() {\n                textView.append(\" onComplete\");\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onComplete\");\n            }\n        };\n    }\n```\nDisposable****\n\n```\n @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        disposables.clear(); // do not send event after activity has been destroyed\n    }\n\n    /*\n     * Example to understand how to use disposables.\n     * disposables is cleared in onDestroy of this activity.\n     */\n    void doSomeWork() {\n        disposables.add(sampleObservable()\n                // Run on a background thread\n                .subscribeOn(Schedulers.io())\n                // Be notified on the main thread\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribeWith(new DisposableObserver<String>() {\n                    @Override\n                    public void onComplete() {\n                        textView.append(\" onComplete\");\n                        textView.append(AppConstant.LINE_SEPARATOR);\n                        Log.d(TAG, \" onComplete\");\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        textView.append(\" onError : \" + e.getMessage());\n                        textView.append(AppConstant.LINE_SEPARATOR);\n                        Log.d(TAG, \" onError : \" + e.getMessage());\n                    }\n\n                    @Override\n                    public void onNext(String value) {\n                        textView.append(\" onNext : value : \" + value);\n                        textView.append(AppConstant.LINE_SEPARATOR);\n                        Log.d(TAG, \" onNext value : \" + value);\n                    }\n                }));\n    }\n\n    static Observable<String> sampleObservable() {\n        return Observable.defer(new Callable<ObservableSource<? extends String>>() {\n            @Override\n            public ObservableSource<? extends String> call() throws Exception {\n                // Do some long running operation\n                SystemClock.sleep(2000);\n                return Observable.just(\"one\", \"two\", \"three\", \"four\", \"five\");\n            }\n        });\n    }\n```\n\ntake****\n\n```\n/* Using take operator, it only emits\n    * required number of values. here only 3 out of 5\n    */\n    private void doSomeWork() {\n        getObservable()\n                // Run on a background thread\n                .subscribeOn(Schedulers.io())\n                // Be notified on the main thread\n                .observeOn(AndroidSchedulers.mainThread())\n                .take(3)\n                .subscribe(getObserver());\n    }\n\n    private Observable<Integer> getObservable() {\n        return Observable.just(1, 2, 3, 4, 5);\n    }\n\n    private Observer<Integer> getObserver() {\n        return new Observer<Integer>() {\n\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.d(TAG, \" onSubscribe : \" + d.isDisposed());\n            }\n\n            @Override\n            public void onNext(Integer value) {\n                textView.append(\" onNext : value : \" + value);\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onNext value : \" + value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                textView.append(\" onError : \" + e.getMessage());\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onError : \" + e.getMessage());\n            }\n\n            @Override\n            public void onComplete() {\n                textView.append(\" onComplete\");\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onComplete\");\n            }\n        };\n    }\n```\n\nTimer****\n\n```\n /*\n     * simple example using timer to do something after 2 second\n     */\n    private void doSomeWork() {\n        getObservable()\n                // Run on a background thread\n                .subscribeOn(Schedulers.io())\n                // Be notified on the main thread\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(getObserver());\n    }\n\n    private Observable<? extends Long> getObservable() {\n        return Observable.timer(2, TimeUnit.SECONDS);\n    }\n\n    private Observer<Long> getObserver() {\n        return new Observer<Long>() {\n\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.d(TAG, \" onSubscribe : \" + d.isDisposed());\n            }\n\n            @Override\n            public void onNext(Long value) {\n                textView.append(\" onNext : value : \" + value);\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onNext : value : \" + value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                textView.append(\" onError : \" + e.getMessage());\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onError : \" + e.getMessage());\n            }\n\n            @Override\n            public void onComplete() {\n                textView.append(\" onComplete\");\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onComplete\");\n            }\n        };\n    }\n```\n\nInterval****\n\n```\n@Override\n    protected void onDestroy() {\n        super.onDestroy();\n        disposables.clear(); // clearing it : do not emit after destroy\n    }\n\n    /*\n     * simple example using interval to run task at an interval of 2 sec\n     * which start immediately\n     */\n    private void doSomeWork() {\n        disposables.add(getObservable()\n                // Run on a background thread\n                .subscribeOn(Schedulers.io())\n                // Be notified on the main thread\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribeWith(getObserver()));\n    }\n\n    private Observable<? extends Long> getObservable() {\n        return Observable.interval(0, 2, TimeUnit.SECONDS);\n    }\n\n    private DisposableObserver<Long> getObserver() {\n        return new DisposableObserver<Long>() {\n\n            @Override\n            public void onNext(Long value) {\n                textView.append(\" onNext : value : \" + value);\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onNext : value : \" + value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                textView.append(\" onError : \" + e.getMessage());\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onError : \" + e.getMessage());\n            }\n\n            @Override\n            public void onComplete() {\n                textView.append(\" onComplete\");\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onComplete\");\n            }\n        };\n    }\n```\n\nSingleObserver****\n\n```\n /*\n     * simple example using SingleObserver\n     */\n    private void doSomeWork() {\n        Single.just(\"Amit\")\n                .subscribe(getSingleObserver());\n    }\n\n    private SingleObserver<String> getSingleObserver() {\n        return new SingleObserver<String>() {\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.d(TAG, \" onSubscribe : \" + d.isDisposed());\n            }\n\n            @Override\n            public void onSuccess(String value) {\n                textView.append(\" onNext : value : \" + value);\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onNext value : \" + value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                textView.append(\" onError : \" + e.getMessage());\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onError : \" + e.getMessage());\n            }\n        };\n    }\n```\n\nCompletableObserver****\n\n```\n/*\n     * simple example using CompletableObserver\n     */\n    private void doSomeWork() {\n        Completable completable = Completable.timer(1000, TimeUnit.MILLISECONDS);\n\n        completable\n                .subscribeOn(Schedulers.io())\n                // Be notified on the main thread\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(getCompletableObserver());\n    }\n\n    private CompletableObserver getCompletableObserver() {\n        return new CompletableObserver() {\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.d(TAG, \" onSubscribe : \" + d.isDisposed());\n            }\n\n            @Override\n            public void onComplete() {\n                textView.append(\" onComplete\");\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onComplete\");\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                textView.append(\" onError : \" + e.getMessage());\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onError : \" + e.getMessage());\n            }\n        };\n    }\n```\n\n\n```\n /*\n     * simple example using Flowable\n     */\n    private void doSomeWork() {\n\n        Flowable<Integer> observable = Flowable.just(1, 2, 3, 4);\n\n        observable.reduce(50, new BiFunction<Integer, Integer, Integer>() {\n            @Override\n            public Integer apply(Integer t1, Integer t2) {\n                return t1 + t2;\n            }\n        }).subscribe(getObserver());\n\n    }\n\n    private SingleObserver<Integer> getObserver() {\n\n        return new SingleObserver<Integer>() {\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.d(TAG, \" onSubscribe : \" + d.isDisposed());\n            }\n\n            @Override\n            public void onSuccess(Integer value) {\n                textView.append(\" onSuccess : value : \" + value);\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onSuccess : value : \" + value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                textView.append(\" onError : \" + e.getMessage());\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onError : \" + e.getMessage());\n            }\n        };\n    }\n```\n\n\n```\n/*\n     * simple example using reduce to add all the number\n     */\n    private void doSomeWork() {\n        getObservable()\n                .reduce(new BiFunction<Integer, Integer, Integer>() {\n                    @Override\n                    public Integer apply(Integer t1, Integer t2) {\n                        return t1 + t2;\n                    }\n                })\n                .subscribe(getObserver());\n    }\n\n    private Observable<Integer> getObservable() {\n        return Observable.just(1, 2, 3, 4);\n    }\n\n    private MaybeObserver<Integer> getObserver() {\n        return new MaybeObserver<Integer>() {\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.d(TAG, \" onSubscribe : \" + d.isDisposed());\n            }\n\n            @Override\n            public void onSuccess(Integer value) {\n                textView.append(\" onSuccess : value : \" + value);\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onSuccess : value : \" + value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                textView.append(\" onError : \" + e.getMessage());\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onError : \" + e.getMessage());\n            }\n\n            @Override\n            public void onComplete() {\n                textView.append(\" onComplete\");\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onComplete\");\n            }\n        };\n    }\n\n```\n\n```\n/*\n     * simple example using buffer operator - bundles all emitted values into a list\n     */\n    private void doSomeWork() {\n\n        Observable<List<String>> buffered = getObservable().buffer(3, 1);\n\n        // 3 means,  it takes max of three from its start index and create list\n        // 1 means, it jumps one step every time\n        // so the it gives the following list\n        // 1 - one, two, three\n        // 2 - two, three, four\n        // 3 - three, four, five\n        // 4 - four, five\n        // 5 - five\n\n        buffered.subscribe(getObserver());\n    }\n\n    private Observable<String> getObservable() {\n        return Observable.just(\"one\", \"two\", \"three\", \"four\", \"five\");\n    }\n\n    private Observer<List<String>> getObserver() {\n        return new Observer<List<String>>() {\n\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.d(TAG, \" onSubscribe : \" + d.isDisposed());\n            }\n\n            @Override\n            public void onNext(List<String> stringList) {\n                textView.append(\" onNext size : \" + stringList.size());\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onNext : size :\" + stringList.size());\n                for (String value : stringList) {\n                    textView.append(\" value : \" + value);\n                    textView.append(AppConstant.LINE_SEPARATOR);\n                    Log.d(TAG, \" : value :\" + value);\n                }\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                textView.append(\" onError : \" + e.getMessage());\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onError : \" + e.getMessage());\n            }\n\n            @Override\n            public void onComplete() {\n                textView.append(\" onComplete\");\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onComplete\");\n            }\n        };\n    }\n```\n\n```\n /*\n     * simple example by using filter operator to emit only even value\n     *\n     */\n    private void doSomeWork() {\n        Observable.just(1, 2, 3, 4, 5, 6)\n                .filter(new Predicate<Integer>() {\n                    @Override\n                    public boolean test(Integer integer) throws Exception {\n                        return integer % 2 == 0;\n                    }\n                })\n                .subscribe(getObserver());\n    }\n\n\n    private Observer<Integer> getObserver() {\n        return new Observer<Integer>() {\n\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.d(TAG, \" onSubscribe : \" + d.isDisposed());\n            }\n\n            @Override\n            public void onNext(Integer value) {\n                textView.append(\" onNext : \");\n                textView.append(AppConstant.LINE_SEPARATOR);\n                textView.append(\" value : \" + value);\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onNext \");\n                Log.d(TAG, \" value : \" + value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                textView.append(\" onError : \" + e.getMessage());\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onError : \" + e.getMessage());\n            }\n\n            @Override\n            public void onComplete() {\n                textView.append(\" onComplete\");\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onComplete\");\n            }\n        };\n    }\n```\n\n```\n/* Using replay operator, replay ensure that all observers see the same sequence\n     * of emitted items, even if they subscribe after the Observable has begun emitting items\n     */\n    private void doSomeWork() {\n\n        PublishSubject<Integer> source = PublishSubject.create();\n        ConnectableObservable<Integer> connectableObservable = source.replay(3); // bufferSize = 3 to retain 3 values to replay\n        connectableObservable.connect(); // connecting the connectableObservable\n\n        connectableObservable.subscribe(getFirstObserver());\n\n        source.onNext(1);\n        source.onNext(2);\n        source.onNext(3);\n        source.onNext(4);\n        source.onComplete();\n\n        /*\n         * it will emit 2, 3, 4 as (count = 3), retains the 3 values for replay\n         */\n        connectableObservable.subscribe(getSecondObserver());\n\n    }\n\n\n    private Observer<Integer> getFirstObserver() {\n        return new Observer<Integer>() {\n\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.d(TAG, \" First onSubscribe : \" + d.isDisposed());\n            }\n\n            @Override\n            public void onNext(Integer value) {\n                textView.append(\" First onNext : value : \" + value);\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" First onNext value : \" + value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                textView.append(\" First onError : \" + e.getMessage());\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" First onError : \" + e.getMessage());\n            }\n\n            @Override\n            public void onComplete() {\n                textView.append(\" First onComplete\");\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" First onComplete\");\n            }\n        };\n    }\n\n    private Observer<Integer> getSecondObserver() {\n        return new Observer<Integer>() {\n\n            @Override\n            public void onSubscribe(Disposable d) {\n                textView.append(\" Second onSubscribe : isDisposed :\" + d.isDisposed());\n                Log.d(TAG, \" Second onSubscribe : \" + d.isDisposed());\n                textView.append(AppConstant.LINE_SEPARATOR);\n            }\n\n            @Override\n            public void onNext(Integer value) {\n                textView.append(\" Second onNext : value : \" + value);\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" Second onNext value : \" + value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                textView.append(\" Second onError : \" + e.getMessage());\n                Log.d(TAG, \" Second onError : \" + e.getMessage());\n            }\n\n            @Override\n            public void onComplete() {\n                textView.append(\" Second onComplete\");\n                Log.d(TAG, \" Second onComplete\");\n            }\n        };\n    }\n```\n\n```\n /*\n     * Using concat operator to combine Observable : concat maintain\n     * the order of Observable.\n     * It will emit all the 7 values in order\n     * here - first \"A1\", \"A2\", \"A3\", \"A4\" and then \"B1\", \"B2\", \"B3\"\n     * first all from the first Observable and then\n     * all from the second Observable all in order\n     */\n    private void doSomeWork() {\n        final String[] aStrings = {\"A1\", \"A2\", \"A3\", \"A4\"};\n        final String[] bStrings = {\"B1\", \"B2\", \"B3\"};\n\n        final Observable<String> aObservable = Observable.fromArray(aStrings);\n        final Observable<String> bObservable = Observable.fromArray(bStrings);\n\n        Observable.concat(aObservable, bObservable)\n                .subscribe(getObserver());\n    }\n\n\n    private Observer<String> getObserver() {\n        return new Observer<String>() {\n\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.d(TAG, \" onSubscribe : \" + d.isDisposed());\n            }\n\n            @Override\n            public void onNext(String value) {\n                textView.append(\" onNext : value : \" + value);\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onNext : value : \" + value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                textView.append(\" onError : \" + e.getMessage());\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onError : \" + e.getMessage());\n            }\n\n            @Override\n            public void onComplete() {\n                textView.append(\" onComplete\");\n                textView.append(AppConstant.LINE_SEPARATOR);\n                Log.d(TAG, \" onComplete\");\n            }\n        };\n    }\n```\n","tags":["android"],"categories":["RxJava2"]},{"title":"swift学习","url":"/2016/11/16/swift/","content":"\n#字段 dictionary\n```\nvar animalGroupsDict = [\"whales\":\"pod\", \"geese\":\"flock\", \"lions\":\"pride\"]\n\nvar groupsDict = [String:String]()\n```\n\n##常见用法\n```\nvar lifeSpanDict = [\"African Grey Parrot\": 50...70, \"Tiger Salamander\": 12...15,\n    \"Bottlenose Dolphin\": 20...30]\n\nvar averageLifeSpanDict = [String:Range<Int>]()\n```\n<font color=#ff0000 size=3 > ... 运算符代表某个区间 ，如 50... 70就是50到70之间的某个数</font>\n\t\t\n\n```swift\n\n//Adding item to a dictionary\n\nanimalGrounpsDict[\"crows\"] = \"murder\"\nanimalGrounpsDict[\"monkeys\"] = \"troop\"\n```\n```\n//the count method is available to all collections, count方法所有的集合都有\nanimalGrounpsDict.count\n\n```\n```\n//Removing items from a dictionary\nanimalGroupsDict[\"monkeys\"] = nil\n\n```\n```\n//Update a value \nanimalGrounpsDict[\"monkeys\"] = [\"barrel\"]\n```\n```\nvar group = animalGrounpsDict.updateValue[\"gaggle\", forkey:\"geese\"]\ngroup.dynamicType （结果为 Optional<String>.Type） \n//首先更新gaggle的种类为geese，并返回 geese ,通过group.dynamicType获取group的类型  \n\n```\n```\n//Retrieving the value for a particular key,获取key对应的值\nlet groupOfWhales = animalGroupsDict[\"whales\"] \n\nif letgrounpOfWhales = animalGroupsDict[“whales”]{\n\t// 如果whales对应的value存在\n}else{\n\t//如果whales对应的value不存在\n}\n\n```\n\n","tags":["swift"],"categories":["总结"]},{"title":"浏览器调起app","url":"/2016/11/16/浏览器调起App/","content":"\n### 现在的h5与Android原生的交互越来越多，为了提升用户的体验，想分享红包或者一些运营活动，都希望能够直接唤起原生的app,并跳转指定的页面。由于Android的浏览器较多，层次不齐，很难适配。下面我介绍的方法，经测试在chrome、uc、魅族自带的浏览器、搜狗浏览器、360浏览器、QQ浏览器、遨游浏览器、火狐浏览器都可适用，甚至可以直接在QQ里面打开，但是在百度浏览器上没有任何反应。\n\n**服务端代码**\n~~~\n~<!DOCTYPE html>    \n<html>    \n<body>    \n<a href=\"scheme://DIDI/startapp?test=test\">启动应用程序</a>   \n</body>    \n</html>~  \n~~~\n**Android只需在AndroidManifest.xml文件里面为启动页面添加**\n\n\n~~~\n<intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n                <data\n                    android:host=\"DIDI\"\n                    android:scheme=\"scheme\" />\n</intent-filter>\n~~~\n\n**当应用启动时**\n<pre><code>\ngetIntent().getDataString();\n</code></pre>\n### 得到的的只就是scheme://DIDI/startapp?test=test，就可以通过得到的值，跳转到App的不同页面。\n## 唤起格式如下：\n~~~\n~<a href=\"[scheme]://[host]/[path]?[query]\">启动应用程序</a> ~\n~~~\n\n## scheme：调起app的标志\n## host:与AndroidManifest里面的host保持一致\n\n","tags":["调起app"],"categories":["总结"]},{"title":"java注解学习笔记","url":"/2016/10/16/annotate/","content":"#\tJava基本注解\n###\t常用注解\t\n>@Override 继承父类 \n\n>@Deprecated 方法已经过时 \n\n>@SupperessWarnings(“depresscated) 忽略警告\t\n\n###\t注解分类\n* 1、源码注解 只存在于源码中，编译成.class文件就不存在了。\n* 2、编译时注解 在源码和.class 文件中存在的注解。\n* 3、运行时注解 在运行阶段还起作用，甚至会影响运行逻辑。\n\n```\n@Target({ElementType.METHOD,ElementType.TYPE})\n@Retantion(RetentionPolicy>RUNTIME)\n@Inherited\n@Documented\n  public @interface Description{\n    String desc();\n    String author();\n    int age() default 18;\n}\n```\n\n* 1、成员类型是受限的，合法的类型包括原始类型及StringClass ,Annotation ,Enumeration。\n* 2、如果只有一个成员的时候，成员名必须取名为value(),在使用时可以忽略成员名和赋值号（=）。\n* 3注解类可以没有成员，没有成员的注解叫做标示注解。\n\n###\t元注解\n\n@Target 注解作用域\n\n            constructor     构造方法声明\n            file        文件声明\n            local variable      局部变量声明\n            method      方法申明\n            package     包申明\n           \n            parameter   参数申明\n            type        类接口\n@Retention 生命周期\n\n            source  只在源码中显示，编译时丢弃\n            class       编译时会记录到class中，运行时忽略\n            runtime 运行时存在，可通过反射获取\n@Inherited 允许子类继承 \n@Docunmented 生成javadoc时包含注解的信息\n\n###\t自定义注解的使用\n\n>@<注解名>（<成员名1>=<成员值1>，<成员名2>=<成员值2>，……）\n \n``` java\n@Description(desc=“I am eyeColor”， author=“Mooc boy” ，age=18) \t\t\npublic String eyeColor(){ \n\treturn “red”; \n}\n```\n##\t\t示例\n```\n@Table(\"pzh\")\npublic class User {\n    @Column(\"name1\")\n    private String name;\n    @Column(\"nickName1\")\n    private String nickName;\n    @Column(\"age1\")\n    private int age;\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public String getNickName() {\n        return nickName;\n    }\n    public void setNickName(String nickName) {\n        this.nickName = nickName;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n}\npublic class Test {\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        User user = new User();\n        user.setName(\"zjp\");\n        show(user);\n    }\n    private static void show(User user) {\n        Class class1 = user.getClass();\n        boolean isExit = class1.isAnnotationPresent(Table.class);\n        if (isExit) {\n            Table table = (Table) class1.getAnnotation(Table.class);\n            System.out.println(\"table value=\" + table.value());\n        }\n        Field[] files = class1.getDeclaredFields();\n        for (Field field : files) {\n            if (field.isAnnotationPresent(Column.class)) {\n                Column column = field.getAnnotation(Column.class);\n                System.out.println(\"column value=\" + column.value());\n                System.out.println(\"file name=\" + field.getName());\n                String filedName=field.getName();\n                String methodNme=\"get\"+filedName.substring(0, 1).toUpperCase()+filedName.substring(1);\n                try {\n                    Method method=class1.getMethod(methodNme);\n                    Object fileValue=method.invoke(user,null);\n                    System.out.println(\"file value=\" + fileValue);\n                }  catch (Exception e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```","tags":["注解"],"categories":["实用"]},{"title":"如何获取Android控件高度","url":"/2016/10/16/measureview/","content":"**如何获取一个控件的长和高，相信很多朋友第一眼看见这个问题都会觉得很简单，直接在onCreate里面调用getWidth、getMeasuredWidth不就可以获得了吗，但是，事实上是并没有简单的，不信的话，你可以去试一下，在onCreate里面，你是无法获得长宽值的，始终为0。\n这是为什么呢，其实熟悉view绘制流程的朋友应该一眼就看出来了，在onCreate中，我们的控件其实还并没有画好，换句话说，等onCreate方法执行完了，我们定义的控件才会被度量(measure)，所以我们在onCreate方法里面通过view.getHeight()获取控件的高度或者宽度肯定是0。**\n\n####有三种解决方式\n1. 1\t\n<pre><code>\nint w=View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);\n\tint h = View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);\nimageView.measure(w,h);\nint height = imageView.getMeasuredHeight();\nint width = imageView.getMeasuredWidth();`\n</code></pre>\n2. 2<pre><code>ViewTreeObserver\nvto = imageView.getViewTreeObserver(); \nvto.addOnPreDrawListener(new\nViewTreeObserver.OnPreDrawListener() {\npublic boolean onPreDraw() { \nvto.removeOnPreDrawListener(this);\nint height = imageView.getMeasuredHeight(); \nint width = imageView.getMeasuredWidth(); \nreturn true;\n}\n})\n</code></pre>\n\n3. 3<pre><code> \nViewTreeObserver\nvto = imageView.getViewTreeObserver();   \nvto.addOnGlobalLayoutListener(new OnGlobalLayoutListener() { \n@Override  \npublic void onGlobalLayout()\n{          \nimageView.getViewTreeObserver().removeGlobalOnLayoutListener(this);\nimageView.getHeight();\nimageView.getWidth();\n}  \n});\n</pre></code>这个方法，我们需要注册一个ViewTreeObserver的监听回调，这个监听回调，就是专门监听绘图的，既然是监听绘图，那么我们自然可以获取测量值了，同时，我们在每次监听前remove前一次的监听，避免重复监听。\n\n","tags":["android"],"categories":["技巧"]},{"title":"Android studio关联Gradle源码","url":"/2016/10/16/Android studio关联源码/","content":"\n###&emsp;&emsp;Android studio都出来这么久了，相信现在的Android开发者大部分都已经在使用了。可能你曾经对Android有多年的开发经验，但是对于gradle这个工具，可能不是很了解，或者之前从来都没接触过。Android studio 对 Gradle也没有自动提示，对于自己从0开始写一个gradle配置文件，还是很难的。或者查看大神代码的时候，对于Gradle的各种配置搞得云里雾里。这个时候就会想，要是能直接在Android studio里面关联源码多好啊。这篇教程就是教你在Android studio里面关联gradle源码。\n\n![android studio查看源码](http://ww1.sinaimg.cn/large/d948997dgy1fe66977rucj20ec051gln.jpg)\n![源码](http://ww1.sinaimg.cn/large/d948997dly1fe66ap7x7wj20g104s748.jpg)\n\n###&nbsp;&nbsp;&nbsp;&nbsp;打开我们的Gradle文件，发现某个写法我们不是很了解，自然的想到了Android studio的看源码大法。点进去才发现，这是什么啊，没有任何注释，方法和参数都还混淆了，怎么玩？这就是因为我们还没能关联源码，我们打开的是class文件，而不是源码。\n\n###既然是关联源码，我们首先肯定是要下载源码。\n\n1. <font color=#ff0000 size=3 face=\"黑体\">查看我们打开的class文件的目录（我的是/Applications/Android Studio.app/Contents/gradle/m2repository/com/android/tools/build/builder/2.3.0)</font>\t\t\n2. <font color=#ff0000 size=3 face=\"黑体\">打开moven网站下载源码，可以在[maven网站](http://search.maven.org/#search%7Cga%7C1%7C)下载</font>\t\n3. <font color=#ff0000 size=3 face=\"黑体\">搜索com.android.tools.bulid,找到Builder，并且下载源码</font> \t\n4. <font color=#ff0000 size=3 face=\"黑体\">copy下载下来的源码，到第一步对应的路径下，重启或者rebulid 一下，就可以使用Android studio的查看源码大发查看了，有详细的注释，还有科学的命名，配置gradle越来越简单了。</font>\n \t\t\n  ![关联了源码之后](http://ww1.sinaimg.cn/large/d948997dgy1fe66fdgjpjj20xe07wmyb.jpg)\n   \n\n\n","tags":["gradle"],"categories":["关联"]},{"title":"支付分享","url":"/2016/10/16/share/","content":"  最近由于公司想弄一个新手推荐活动，因为是推荐活动，必须借用现在流行的社交软件进行各种分享，只要形式有微信分享到好友或者朋友圈、QQ分享给好友或者空间、微博分享和短信分享等。下面我就跟大家一起聊下在分享的过程中所遇到的各种坑。本文来自于自己的经验，不足的地方还请指正。首先说下我是怎么实现的，然后给大家说下实现过程中应该注意的。\n\n##\t\t微信支付\n\n1. 微信支付注册\t\n``` \napi = WXAPIFactory.createWXAPI(this, AppConfig.WEIXIN_PAY_ID, false);\n```\n\n   > 第二个参数是我们在微信开放平台申请的Pay_ID\t\n   > 第三个参数代表是否进行校验.\t\n\n2. 微信推荐我们从后台生成订单，然后再通过app调起微信进行支付，其实也可以App里面就生成订单，然后Appc里面进行支付。两种都是可行的，但是大多数App并不是简简单单的支付，可能还要数据库入库，或者进行一些其他的操作，通过后台生成订单就比较好，大家可以根据自己的需求，选择适合自己的。\n3. 当订单生成之后，我们需要拼接调起微信支付的请求PayReq：\n\n ```java\n\tPayReq request = new PayReq();\n \trequest.appId = object.getString(\"appId\");\n \trequest.partnerId = object.getString(\"partnerId\");\n \trequest.prepayId = object.getString(\"prepayId\");\n \trequest.packageValue = object.getString(\"package\");\n \trequest.nonceStr = object.getString(\"nonceStr\");\n \trequest.timeStamp = object.getString(\"timeStamp\");\n \trequest.sign = object.getString(\"sign\");\n \tapi.sendReq(request);\t\n ```\n  **通过api.sendReq(),我们就能调起微信进行支付啦。一般情况下还是比较容易调起 的，如果没反应，请检查自己的APP_ID，然后在检查一下自己的PayReq，然后在检查一下，是否添加了必须的权限。**\n   \n4. 微信成功调起，输入密码成功支付之后，如果我们想要知道微信支付的结果，就必须在应用包名下，新建一个wxapi的包，然后新建一个WXPayEntryActivity，重点注意包名和activity的名字不要写错，微信是通过包名加activity的名称通过反射跳转到该页面。这样还不够，需要实现微信定义的IWXAPIEventHandler，重写onResp和onReq，在onReq里面我们可以对app发送到微信的请求做些处理，在onResp我们可以接收到微信返回的结果。返回结果bean里面的errCode比较简单，0代表成功，-1代表失败，-2代表取消。这样还不够，还要调用iwxapi.handleIntent(getIntent(), this)在能正真的接收到微信返回的消息。如果没能成功的接收到微信返回的消息，依次检查包名activity名是否与规定的不符，检查是否在AndroidMianfest里面注册了activity，然后是否调用了iwxapi.handleIntent(getIntent(), this)。\n\n###\t以上就是微信支付的总结，主要注意\n1. 权限是否添加\n2. **wxapi和WXPayEntryActivity的包名是否正确**\n3. **在 WXPayEntryActivity里面是否调用了iwxapi.handleIntent(getIntent(), this)**\n\n## 微信分享\n1. 首先检测手机是否安装了微信，通过微信自定义的方法\n\n\t```java\nIWXAPI api = WXAPIFactory.createWXAPI(context, AppConfig.WEIXIN_PAY_ID, false);\n  if (api.isWXAppInstalled() && api.isWXAppSupportAPI()) {\n         flag = true;\n    }\n```\n\n\t>api.isWXAppInstalled（）返回微信是否安装\n\t>api.isWXAppSupportAPI（）返回微信是否支持支付\n\n2. 在初始化了api之后，我们需要把应用注册到微信`api.registerApp(AppConfig.WEIXIN_PAY_ID);`\n3. 下面就是创建WXobject和wxMessage，说明文档上有具体的代码，分享文字，图片，音频等详细代码，我就不一一重述了，大家自己去微信开放平台查看代码。通过api.sendReq(req)我们就能调起微信分享的界面。\n4. 跟微信支付一样，我们 需要在wxapi包下面新建一个WXEntryActivity，并且实现IWXAPIEventHandler才能接收到是否分享成功。\n\n###\t如果没有分享成功，依次检查：\n\t\n1. **分享之前时候注册了应用到微信**\n\n\t```java\n\tapi.registerApp(AppConfig.WEIXIN_PAY_ID);\n\t```\n\n2. **WXEntryActivity是否注册了**\n3. **是否添加了必要的权限**\n\n\n## QQ分享\n1. 首先导入必须的mta_sdk.jar和open_sdk.jar\n2. AndroidManifest里面添加\n3. Tencent是QQ的入口，需要实例化Tencent：\n`Tencent：mTencent = Tencent.createInstance(APP_ID, this.getApplicationContext());`\n\n4. 实现回调：IUiListener，QQ的所有操作都是通过这个回调的，如果要想接收到QQ的回调，还需要重写onActivityRes\n\n###\t如果没有分享成功，依次检查：\n1. **是否添加必要的权限**\n2. **是否在Manifest里面注册了必要的activity，重点注意的是 <data android:scheme=\"tencent\"+appkey />，这里以Tencent 开头，后面的数字是自己申请的appkey，当初就是这里没有处理，导致QQ一直无法调起**\n3. **如果分享成功，但是不能接收到回调，检查是否重写了onActivityResult()**\n\n## 微博分享\n#####\t微博里面文档比较全，他涉及到的东西也非常多，我们移动app比较关注的是他的分享和登陆。\n 1. 导入jar包和so库\n 2. 在Manifest里面添加:\n \n ```xml\n \t\t\t<activity android:name=\"com.sina.weibo.sdk.component.WeiboSdkBrowser\"           android:configChanges=\"keyboardHidden|orientation\"\n            android:exported=\"false\"\n            android:windowSoftInputMode=\"adjustResize\">\n            </activity>\n ```\n \n      >这是微博自带的有个webview，当你手机没有安装微博的时候，可以通过H5实现分享和登陆。如果没有注册的话，当没安装微博客户端的时候，无法调起微博H5页面；\n 3. 实现IWeiboHandler.Response接口，用于接收微博分享的结果\n 4. 实例化IWeiboShareAPI、注册，处理微博分享 的结果：\n \n ```java\n mWeiboShareAPI=WeiboShareSDK.createWeiboAPI(context.getApplicationContext(), AppConfig.WEIBO_APPID);\n        mWeiboShareAPI.registerApp();\n mWeiboShareAPI.handleWeiboResponse(getIntent(), this);//处理微博分享的结果；\n ```\n\n###如果没有分享成功，一次检查：\n1. 因为微博审核比较严格，只有当审核通过之后才能分享成功，有可能并不是你的代码问题，而是审核没有通过，导致分享失败\n2. 在没有安装微博的情况下，不能跳到微博分享的H5,检查Manifest里面是否注册了微博的H5 webview;\n3. 添加必须的权限**\n下面分享我自己写的一个ShareUtils，里面实现了QQ，微信，微博分享，大家可以自行下载对照。\n\n\t```java\n\timport android.app.Activity;\n\timport android.content.Context;\n\timport android.content.Intent;\n\timport android.content.SharedPreferences;\n\timport android.graphics.Bitmap;\n\timport android.graphics.BitmapFactory;\n\timport android.net.Uri;\n\timport android.os.Bundle;\n\timport android.widget.Toast;\nimport com.sina.weibo.sdk.api.TextObject;\nimport com.sina.weibo.sdk.api.WebpageObject;\nimport com.sina.weibo.sdk.api.WeiboMessage;\nimport com.sina.weibo.sdk.api.WeiboMultiMessage;\nimport com.sina.weibo.sdk.api.share.IWeiboShareAPI;\nimport com.sina.weibo.sdk.api.share.SendMessageToWeiboRequest;\nimport com.sina.weibo.sdk.api.share.SendMultiMessageToWeiboRequest;\nimport com.sina.weibo.sdk.api.share.WeiboShareSDK;\nimport com.sina.weibo.sdk.auth.AuthInfo;\nimport com.sina.weibo.sdk.auth.Oauth2AccessToken;\nimport com.sina.weibo.sdk.auth.WeiboAuthListener;\nimport com.sina.weibo.sdk.exception.WeiboException;\nimport com.sina.weibo.sdk.utils.Utility;\nimport com.tencent.connect.common.Constants;\nimport com.tencent.connect.share.QQShare;\nimport com.tencent.connect.share.QzoneShare;\nimport com.tencent.mm.sdk.modelmsg.SendMessageToWX;\nimport com.tencent.mm.sdk.modelmsg.WXMediaMessage;\nimport com.tencent.mm.sdk.modelmsg.WXWebpageObject;\nimport com.tencent.mm.sdk.openapi.IWXAPI;\nimport com.tencent.mm.sdk.openapi.WXAPIFactory;\nimport com.tencent.tauth.IUiListener;\nimport com.tencent.tauth.Tencent;\nimport java.io.ByteArrayOutputStream;\nimport java.util.ArrayList;\npublic class ShareUtils {\n    private static final String PREFERENCES_NAME = \"com_weibo_sdk_android\";\n    private static final String KEY_UID = \"uid\";\n    private static final String KEY_ACCESS_TOKEN = \"access_token\";\n    private static final String KEY_EXPIRES_IN = \"expires_in\";\n    private static final String KEY_REFRESH_TOKEN = \"refresh_token\";\n\n\n    public static boolean isWeiXinInstallAndSupport(Context context) {\n        boolean flag = false;\n        IWXAPI api = WXAPIFactory.createWXAPI(context, AppConfig.WEIXIN_PAY_ID, false);\n        if (api.isWXAppInstalled() && api.isWXAppSupportAPI()) {\n            flag = true;\n        }\n        return flag;\n    }\n\n\n    /**\n     * @param context\n     * @param type    1:分享到朋友圈            2：分享到微信好友\n     * @param title   标题\n     * @param url     跳转url\n     * @param imageId 图片id\n     */\n    public static void shareToWeChat(Context context, int type, String title, String url, int imageId) {\n        IWXAPI api = WXAPIFactory.createWXAPI(context, AppConfig.WEIXIN_PAY_ID);\n        api.registerApp(AppConfig.WEIXIN_PAY_ID);\n\n        Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), imageId);\n        Bitmap thumbBmp = Bitmap.createScaledBitmap(bitmap, 150, 150, true);\n        bitmap.recycle();\n\n        WXWebpageObject webpageObject = new WXWebpageObject();\n        webpageObject.webpageUrl = url;\n\n        WXMediaMessage msg = new WXMediaMessage();\n        msg.mediaObject = webpageObject;\n        msg.title = title;\n        msg.thumbData = bmpToByteArray(thumbBmp, true);\n        SendMessageToWX.Req req = new SendMessageToWX.Req();\n        req.message = msg;\n        req.transaction = System.currentTimeMillis() + \"\";\n        req.scene = type == 1 ? SendMessageToWX.Req.WXSceneTimeline : SendMessageToWX.Req.WXSceneSession;\n        api.sendReq(req);\n    }\n\n    /**\n     * @param context\n     * @param title       标题\n     * @param description 描述\n     * @param url         跳转URL\n     * @param imageUrl    图片链接\n     * @param callBack\n     */\n    public static void shareToQQ(Tencent mTencent, Context context, String title, String description, String url, String imageUrl, IUiListener callBack) {\n        Bundle params = new Bundle();\n        params.putInt(QQShare.SHARE_TO_QQ_KEY_TYPE, QQShare.SHARE_TO_QQ_TYPE_DEFAULT);\n        params.putString(QQShare.SHARE_TO_QQ_TITLE, title);\n        params.putString(QQShare.SHARE_TO_QQ_SUMMARY, description);\n        params.putString(QQShare.SHARE_TO_QQ_TARGET_URL, url);\n        params.putString(QQShare.SHARE_TO_QQ_IMAGE_URL, imageUrl);\n        params.putString(QQShare.SHARE_TO_QQ_APP_NAME, App名字);\n        mTencent.shareToQQ((Activity) context, params, callBack);\n    }\n\n\n    /**\n     * @param context\n     * @param picLists    图片arraylist,可以分享多张图片\n     * @param title       标题\n     * @param description 描述\n     * @param url         跳转url\n     * @param callBack\n     */\n    public static void shareToZone(Context context, ArrayList<String> picLists, String title, String description, String url, IUiListener callBack) {\n        Tencent mTencent = Tencent.createInstance(AppConfig.QQ_APPID, context.getApplicationContext());\n        final Bundle params = new Bundle();\n        params.putInt(QzoneShare.SHARE_TO_QZONE_KEY_TYPE, QzoneShare.SHARE_TO_QZONE_TYPE_IMAGE_TEXT);\n        params.putString(QzoneShare.SHARE_TO_QQ_TITLE, title);//必填\n        params.putString(QzoneShare.SHARE_TO_QQ_SUMMARY, description);//选填\n        params.putString(QzoneShare.SHARE_TO_QQ_TARGET_URL, url);//必填\n        params.putStringArrayList(QzoneShare.SHARE_TO_QQ_IMAGE_URL, picLists);\n        mTencent.shareToQzone((Activity) context, params, callBack);\n    }\n\n    /**\n     * @param context\n     * @param phoneNum 短信接受者电话号码\n     * @param content  短信内容\n     */\n    public static void shareToSms(Context context, String phoneNum, String content) {\n        Uri smsToUri = Uri.parse(\"smsto:\" + phoneNum);\n\n        Intent intent = new Intent(Intent.ACTION_SENDTO, smsToUri);\n\n        intent.putExtra(\"sms_body\", content);\n\n        context.startActivity(intent);\n    }\n\n\n    /**\n     * @param context\n     * @param resId       显示图片\n     * @param title       标题\n     * @param description 描述\n     * @param url         跳转url\n     */\n    public static void shareToWeibo(IWeiboShareAPI api, final Context context, int resId, String title, String description, String url) {\n        WebpageObject mediaObject = new WebpageObject();\n        mediaObject.identify = Utility.generateGUID();\n        mediaObject.title = title;\n        mediaObject.description = title;\n\n        TextObject textObject = new TextObject();\n        textObject.text = title;\n\n        Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), resId);\n        // 设置 Bitmap 类型的图片到视频对象里         设置缩略图。 注意：最终压缩过的缩略图大小不得超过 32kb。\n        mediaObject.setThumbImage(bitmap);\n        mediaObject.actionUrl = url;\n        mediaObject.defaultText = title;\n\n        WeiboMultiMessage weiboMessage = new WeiboMultiMessage();\n        weiboMessage.mediaObject = mediaObject;\n        weiboMessage.textObject=textObject;\n        SendMultiMessageToWeiboRequest request = new SendMultiMessageToWeiboRequest();\n        // 用transaction唯一标识一个请求\n        request.transaction = String.valueOf(System.currentTimeMillis());\n        request.multiMessage = weiboMessage;\n        // 3. 发送请求消息到微博，唤起微博分享界面\n\n\n        AuthInfo authInfo = new AuthInfo(context, AppConfig.WEIBO_APPID, \"\", AppConfig.SCOPE);\n        Oauth2AccessToken accessToken = readAccessToken(context.getApplicationContext());\n        String token = \"\";\n        if (accessToken != null) {\n            token = accessToken.getToken();\n        }\n        api.sendRequest((Activity) context, request, authInfo, token, new WeiboAuthListener() {\n\n            @Override\n            public void onWeiboException(WeiboException arg0) {\n            }\n\n            @Override\n            public void onComplete(Bundle bundle) {\n                // TODO Auto-generated method stub\n                Oauth2AccessToken newToken = Oauth2AccessToken.parseAccessToken(bundle);\n                writeAccessToken(context.getApplicationContext(), newToken);\n            }\n\n            @Override\n            public void onCancel() {\n            }\n        });\n\n    }\n\n    public static void writeAccessToken(Context context, Oauth2AccessToken token) {\n        if (null == context || null == token) {\n            return;\n        }\n\n        SharedPreferences pref = context.getSharedPreferences(PREFERENCES_NAME, Context.MODE_APPEND);\n        SharedPreferences.Editor editor = pref.edit();\n        editor.putString(KEY_UID, token.getUid());\n        editor.putString(KEY_ACCESS_TOKEN, token.getToken());\n        editor.putString(KEY_REFRESH_TOKEN, token.getRefreshToken());\n        editor.putLong(KEY_EXPIRES_IN, token.getExpiresTime());\n        editor.commit();\n    }\n\n    public static Oauth2AccessToken readAccessToken(Context context) {\n        if (null == context) {\n            return null;\n        }\n\n        Oauth2AccessToken token = new Oauth2AccessToken();\n        SharedPreferences pref = context.getSharedPreferences(PREFERENCES_NAME, Context.MODE_APPEND);\n        token.setUid(pref.getString(KEY_UID, \"\"));\n        token.setToken(pref.getString(KEY_ACCESS_TOKEN, \"\"));\n        token.setRefreshToken(pref.getString(KEY_REFRESH_TOKEN, \"\"));\n        token.setExpiresTime(pref.getLong(KEY_EXPIRES_IN, 0));\n\n        return token;\n    }\n\n    public static byte[] bmpToByteArray(final Bitmap bmp, final boolean needRecycle) {\n        ByteArrayOutputStream output = new ByteArrayOutputStream();\n        bmp.compress(Bitmap.CompressFormat.PNG, 100, output);\n        if (needRecycle) {\n            bmp.recycle();\n        }\n        byte[] result = output.toByteArray();\n        try {\n            output.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n}\n```\n**文章写得不好，欢迎大家吐槽**\n","tags":["分享"],"categories":["实用"]},{"title":"webview调起微信支付宝","url":"/2016/10/16/pay/","content":"\n\n","tags":["支付宝"],"categories":["支付"]}]